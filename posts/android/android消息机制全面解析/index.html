<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android消息机制全面解析 | Petrichor's blog</title>
<meta name=keywords content="Android,Handler"><meta name=description content="(1),Android消息机制概述
Android中的消息机制主要指 Handler的运行机制 以及 MessageQueue，Looper的工作过程 ，三者相互协作，保证着消息的接收，发送，处理，执行。


​                                                            图片来自郭神的《第一行代码》
先简单的介绍一下 Android 中 消息机制大家庭的主要成员 :


Handler : 是Android消息机制的上层接口，最为大家常用，相当于Android消息机制的入口，我们通过使用Handler发送消息来引起消息机制的循环。通常用于:在子线程执行完耗时任务完后，更新UI。


MessageQueue : 存储 消息(Message) 对象的消息队列，实则是单链表结构.


Looper : 用于无限的从 MessageQueue中取出消息，相当于消息的永动机，如果有新的消息，则处理执行，若没有，则就一直等待，堵塞。Looper** 所在的线程是 创建 Handler 时所在的线程。
主线程创建Handler时，会自动创建一个Looper,但是子线程并不会自动创建Looper


ThreadLocal : 在每个线程互不干扰的存储，提供数据，以此来获取当前线程的Looper


ActivityThread : Android 的主线程，也叫UI线程，主线程被创建时 自动初始化主线程的 Looper对象。


问题 : 大家都知道只有在UI线程才能对UI元素进行操作，在子线程更改UI就会报错，为什么？
看完《Android艺术开发探索》 这本书的第10章之后我也才明白

Android中的UI控件不是线程安全的，如果在子线程中也能修改UI元素，那多线程的时，共同访问同一个UI元素，就会导致这个UI元素处于我们不可预知的状态，这个线程让它往左一点，那个线程让它往右一点，UI该听谁的，好tm乱。。 干脆我就只听主线程的把。

问题 : 那为什么不通过对访问UI控件的子线程加上锁机制呢 ？
这个很简单了，如果为不同的线程访问同一UI元素加上锁机制，那我们程序员写相关代码的时候会变得超级麻烦。。。 改个UI还得考虑它是不是已经被别的线程占用了，被占用了，还得让那个线程释放锁。。。线程再多一点的话，大大地加大了程序员地工作量.
而且加上锁机制无疑会由于线程堵塞地原因降低访问UI的效率，帧率降低，体验也会不友好。
让UI元素只能再主线程访问就会省下很多事，创建一个Handler就行了。
下面从整体概述一下 消息机制的整个工作过程 :


Handler 创建时会采用当前线程的 Looper来构建内部的消息循环系统，如果Handler在子线程，则一开始是没有Looper对象的(解决方法稍后介绍)，主线程ActivityThread默认有一个Looper。


Handler创建完毕，通过 post方法传入Runnable对象，或者通过sendMessage(Message msg)发送消息。
post()方法里也是通过调用send()实现的


send()方法被调用后，调用 MessageQueue的enqueueMessage()方法将消息发送到消息队列中，等待被处理。


Looper对象运行在Handler所在的线程，从MessageQueue消息队列中不断地取出消息，处理，所以业务逻辑(通常是更新UI)就运行在Looper的线程中。



接下来从局部来分析消息机制的每个成员。"><meta name=author content="Petrichor"><link rel=canonical href=https://chenyongda2018.github.io/posts/android/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://chenyongda2018.github.io/newfav.png><link rel=icon type=image/png sizes=16x16 href=https://chenyongda2018.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://chenyongda2018.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://chenyongda2018.github.io/apple-touch-icon.png><link rel=mask-icon href=https://chenyongda2018.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://chenyongda2018.github.io/posts/android/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://chenyongda2018.github.io/posts/android/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="Petrichor's blog"><meta property="og:title" content="Android消息机制全面解析"><meta property="og:description" content="(1),Android消息机制概述 Android中的消息机制主要指 Handler的运行机制 以及 MessageQueue，Looper的工作过程 ，三者相互协作，保证着消息的接收，发送，处理，执行。
​ 图片来自郭神的《第一行代码》
先简单的介绍一下 Android 中 消息机制大家庭的主要成员 :
Handler : 是Android消息机制的上层接口，最为大家常用，相当于Android消息机制的入口，我们通过使用Handler发送消息来引起消息机制的循环。通常用于:在子线程执行完耗时任务完后，更新UI。
MessageQueue : 存储 消息(Message) 对象的消息队列，实则是单链表结构.
Looper : 用于无限的从 MessageQueue中取出消息，相当于消息的永动机，如果有新的消息，则处理执行，若没有，则就一直等待，堵塞。Looper** 所在的线程是 创建 Handler 时所在的线程。
主线程创建Handler时，会自动创建一个Looper,但是子线程并不会自动创建Looper
ThreadLocal : 在每个线程互不干扰的存储，提供数据，以此来获取当前线程的Looper
ActivityThread : Android 的主线程，也叫UI线程，主线程被创建时 自动初始化主线程的 Looper对象。
问题 : 大家都知道只有在UI线程才能对UI元素进行操作，在子线程更改UI就会报错，为什么？ 看完《Android艺术开发探索》 这本书的第10章之后我也才明白
Android中的UI控件不是线程安全的，如果在子线程中也能修改UI元素，那多线程的时，共同访问同一个UI元素，就会导致这个UI元素处于我们不可预知的状态，这个线程让它往左一点，那个线程让它往右一点，UI该听谁的，好tm乱。。 干脆我就只听主线程的把。 问题 : 那为什么不通过对访问UI控件的子线程加上锁机制呢 ？ 这个很简单了，如果为不同的线程访问同一UI元素加上锁机制，那我们程序员写相关代码的时候会变得超级麻烦。。。 改个UI还得考虑它是不是已经被别的线程占用了，被占用了，还得让那个线程释放锁。。。线程再多一点的话，大大地加大了程序员地工作量.
而且加上锁机制无疑会由于线程堵塞地原因降低访问UI的效率，帧率降低，体验也会不友好。
让UI元素只能再主线程访问就会省下很多事，创建一个Handler就行了。
下面从整体概述一下 消息机制的整个工作过程 :
Handler 创建时会采用当前线程的 Looper来构建内部的消息循环系统，如果Handler在子线程，则一开始是没有Looper对象的(解决方法稍后介绍)，主线程ActivityThread默认有一个Looper。
Handler创建完毕，通过 post方法传入Runnable对象，或者通过sendMessage(Message msg)发送消息。
post()方法里也是通过调用send()实现的
send()方法被调用后，调用 MessageQueue的enqueueMessage()方法将消息发送到消息队列中，等待被处理。
Looper对象运行在Handler所在的线程，从MessageQueue消息队列中不断地取出消息，处理，所以业务逻辑(通常是更新UI)就运行在Looper的线程中。
接下来从局部来分析消息机制的每个成员。"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-04-19T20:27:16+08:00"><meta property="article:modified_time" content="2019-04-19T20:27:16+08:00"><meta property="article:tag" content="Android"><meta property="article:tag" content="Handler"><meta property="og:image" content="https://chenyongda2018.github.io/images/profile.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://chenyongda2018.github.io/images/profile.jpg"><meta name=twitter:title content="Android消息机制全面解析"><meta name=twitter:description content="(1),Android消息机制概述
Android中的消息机制主要指 Handler的运行机制 以及 MessageQueue，Looper的工作过程 ，三者相互协作，保证着消息的接收，发送，处理，执行。


​                                                            图片来自郭神的《第一行代码》
先简单的介绍一下 Android 中 消息机制大家庭的主要成员 :


Handler : 是Android消息机制的上层接口，最为大家常用，相当于Android消息机制的入口，我们通过使用Handler发送消息来引起消息机制的循环。通常用于:在子线程执行完耗时任务完后，更新UI。


MessageQueue : 存储 消息(Message) 对象的消息队列，实则是单链表结构.


Looper : 用于无限的从 MessageQueue中取出消息，相当于消息的永动机，如果有新的消息，则处理执行，若没有，则就一直等待，堵塞。Looper** 所在的线程是 创建 Handler 时所在的线程。
主线程创建Handler时，会自动创建一个Looper,但是子线程并不会自动创建Looper


ThreadLocal : 在每个线程互不干扰的存储，提供数据，以此来获取当前线程的Looper


ActivityThread : Android 的主线程，也叫UI线程，主线程被创建时 自动初始化主线程的 Looper对象。


问题 : 大家都知道只有在UI线程才能对UI元素进行操作，在子线程更改UI就会报错，为什么？
看完《Android艺术开发探索》 这本书的第10章之后我也才明白

Android中的UI控件不是线程安全的，如果在子线程中也能修改UI元素，那多线程的时，共同访问同一个UI元素，就会导致这个UI元素处于我们不可预知的状态，这个线程让它往左一点，那个线程让它往右一点，UI该听谁的，好tm乱。。 干脆我就只听主线程的把。

问题 : 那为什么不通过对访问UI控件的子线程加上锁机制呢 ？
这个很简单了，如果为不同的线程访问同一UI元素加上锁机制，那我们程序员写相关代码的时候会变得超级麻烦。。。 改个UI还得考虑它是不是已经被别的线程占用了，被占用了，还得让那个线程释放锁。。。线程再多一点的话，大大地加大了程序员地工作量.
而且加上锁机制无疑会由于线程堵塞地原因降低访问UI的效率，帧率降低，体验也会不友好。
让UI元素只能再主线程访问就会省下很多事，创建一个Handler就行了。
下面从整体概述一下 消息机制的整个工作过程 :


Handler 创建时会采用当前线程的 Looper来构建内部的消息循环系统，如果Handler在子线程，则一开始是没有Looper对象的(解决方法稍后介绍)，主线程ActivityThread默认有一个Looper。


Handler创建完毕，通过 post方法传入Runnable对象，或者通过sendMessage(Message msg)发送消息。
post()方法里也是通过调用send()实现的


send()方法被调用后，调用 MessageQueue的enqueueMessage()方法将消息发送到消息队列中，等待被处理。


Looper对象运行在Handler所在的线程，从MessageQueue消息队列中不断地取出消息，处理，所以业务逻辑(通常是更新UI)就运行在Looper的线程中。



接下来从局部来分析消息机制的每个成员。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://chenyongda2018.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Android消息机制全面解析","item":"https://chenyongda2018.github.io/posts/android/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android消息机制全面解析","name":"Android消息机制全面解析","description":"(1),Android消息机制概述 Android中的消息机制主要指 Handler的运行机制 以及 MessageQueue，Looper的工作过程 ，三者相互协作，保证着消息的接收，发送，处理，执行。\n​ 图片来自郭神的《第一行代码》\n先简单的介绍一下 Android 中 消息机制大家庭的主要成员 :\nHandler : 是Android消息机制的上层接口，最为大家常用，相当于Android消息机制的入口，我们通过使用Handler发送消息来引起消息机制的循环。通常用于:在子线程执行完耗时任务完后，更新UI。\nMessageQueue : 存储 消息(Message) 对象的消息队列，实则是单链表结构.\nLooper : 用于无限的从 MessageQueue中取出消息，相当于消息的永动机，如果有新的消息，则处理执行，若没有，则就一直等待，堵塞。Looper** 所在的线程是 创建 Handler 时所在的线程。\n主线程创建Handler时，会自动创建一个Looper,但是子线程并不会自动创建Looper\nThreadLocal : 在每个线程互不干扰的存储，提供数据，以此来获取当前线程的Looper\nActivityThread : Android 的主线程，也叫UI线程，主线程被创建时 自动初始化主线程的 Looper对象。\n问题 : 大家都知道只有在UI线程才能对UI元素进行操作，在子线程更改UI就会报错，为什么？ 看完《Android艺术开发探索》 这本书的第10章之后我也才明白\nAndroid中的UI控件不是线程安全的，如果在子线程中也能修改UI元素，那多线程的时，共同访问同一个UI元素，就会导致这个UI元素处于我们不可预知的状态，这个线程让它往左一点，那个线程让它往右一点，UI该听谁的，好tm乱。。 干脆我就只听主线程的把。 问题 : 那为什么不通过对访问UI控件的子线程加上锁机制呢 ？ 这个很简单了，如果为不同的线程访问同一UI元素加上锁机制，那我们程序员写相关代码的时候会变得超级麻烦。。。 改个UI还得考虑它是不是已经被别的线程占用了，被占用了，还得让那个线程释放锁。。。线程再多一点的话，大大地加大了程序员地工作量.\n而且加上锁机制无疑会由于线程堵塞地原因降低访问UI的效率，帧率降低，体验也会不友好。\n让UI元素只能再主线程访问就会省下很多事，创建一个Handler就行了。\n下面从整体概述一下 消息机制的整个工作过程 :\nHandler 创建时会采用当前线程的 Looper来构建内部的消息循环系统，如果Handler在子线程，则一开始是没有Looper对象的(解决方法稍后介绍)，主线程ActivityThread默认有一个Looper。\nHandler创建完毕，通过 post方法传入Runnable对象，或者通过sendMessage(Message msg)发送消息。\npost()方法里也是通过调用send()实现的\nsend()方法被调用后，调用 MessageQueue的enqueueMessage()方法将消息发送到消息队列中，等待被处理。\nLooper对象运行在Handler所在的线程，从MessageQueue消息队列中不断地取出消息，处理，所以业务逻辑(通常是更新UI)就运行在Looper的线程中。\n接下来从局部来分析消息机制的每个成员。\n","keywords":["Android","Handler"],"articleBody":"(1),Android消息机制概述 Android中的消息机制主要指 Handler的运行机制 以及 MessageQueue，Looper的工作过程 ，三者相互协作，保证着消息的接收，发送，处理，执行。\n​ 图片来自郭神的《第一行代码》\n先简单的介绍一下 Android 中 消息机制大家庭的主要成员 :\nHandler : 是Android消息机制的上层接口，最为大家常用，相当于Android消息机制的入口，我们通过使用Handler发送消息来引起消息机制的循环。通常用于:在子线程执行完耗时任务完后，更新UI。\nMessageQueue : 存储 消息(Message) 对象的消息队列，实则是单链表结构.\nLooper : 用于无限的从 MessageQueue中取出消息，相当于消息的永动机，如果有新的消息，则处理执行，若没有，则就一直等待，堵塞。Looper** 所在的线程是 创建 Handler 时所在的线程。\n主线程创建Handler时，会自动创建一个Looper,但是子线程并不会自动创建Looper\nThreadLocal : 在每个线程互不干扰的存储，提供数据，以此来获取当前线程的Looper\nActivityThread : Android 的主线程，也叫UI线程，主线程被创建时 自动初始化主线程的 Looper对象。\n问题 : 大家都知道只有在UI线程才能对UI元素进行操作，在子线程更改UI就会报错，为什么？ 看完《Android艺术开发探索》 这本书的第10章之后我也才明白\nAndroid中的UI控件不是线程安全的，如果在子线程中也能修改UI元素，那多线程的时，共同访问同一个UI元素，就会导致这个UI元素处于我们不可预知的状态，这个线程让它往左一点，那个线程让它往右一点，UI该听谁的，好tm乱。。 干脆我就只听主线程的把。 问题 : 那为什么不通过对访问UI控件的子线程加上锁机制呢 ？ 这个很简单了，如果为不同的线程访问同一UI元素加上锁机制，那我们程序员写相关代码的时候会变得超级麻烦。。。 改个UI还得考虑它是不是已经被别的线程占用了，被占用了，还得让那个线程释放锁。。。线程再多一点的话，大大地加大了程序员地工作量.\n而且加上锁机制无疑会由于线程堵塞地原因降低访问UI的效率，帧率降低，体验也会不友好。\n让UI元素只能再主线程访问就会省下很多事，创建一个Handler就行了。\n下面从整体概述一下 消息机制的整个工作过程 :\nHandler 创建时会采用当前线程的 Looper来构建内部的消息循环系统，如果Handler在子线程，则一开始是没有Looper对象的(解决方法稍后介绍)，主线程ActivityThread默认有一个Looper。\nHandler创建完毕，通过 post方法传入Runnable对象，或者通过sendMessage(Message msg)发送消息。\npost()方法里也是通过调用send()实现的\nsend()方法被调用后，调用 MessageQueue的enqueueMessage()方法将消息发送到消息队列中，等待被处理。\nLooper对象运行在Handler所在的线程，从MessageQueue消息队列中不断地取出消息，处理，所以业务逻辑(通常是更新UI)就运行在Looper的线程中。\n接下来从局部来分析消息机制的每个成员。\n(2),ThreadLocal 工作原理 1, 什么是ThreadLocal？ ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中获得存储数据，获得数据，线程之间的ThreadLocal相互独立，且无法获得另一个线程的TheadLocal.\n相对整个程序来说，每个线程的ThreadLocal是局部变量。\n相对一个线程来说，线程内的ThreadLocal是线程的全局变量\nThreadLocal是一个泛型类，可以存储任意类型的对象。\n示例:\npublic class ThreadLocalTest { public static void main(String[] args) { ThreadLocal\u003cBoolean\u003e mThreadLocal = new ThreadLocal\u003cBoolean\u003e(); mThreadLocal.set(true); System.out.println(\"#Main Thread : ThreadLocal \" + mThreadLocal.get()); new Thread( new Runnable() { @Override public void run() { mThreadLocal.set(false); System.out.println(\"#1 Thread : ThreadLocal \" + mThreadLocal.get()); } }).start(); new Thread( new Runnable() { @Override public void run() { System.out.println(\"#2 Thread : ThreadLocal \" + mThreadLocal.get()); } }).start(); } } 我们在主线程创建一个 泛型为Boolean的ThreadLocal，并.set(True),然后在第一个子线程中.set(False)，在第二个子线程中不做修改，直接打印。 可以看到，在不同的线程中获得的值也不同。\n输出 :\n#Main Thread : ThreadLocal true #1 Thread : ThreadLocal false #2 Thread : ThreadLocal null 2，ThreadLocal的实现原理 首先每个线程内部都维护着一个ThreadLocalMap对象\nThread.Java\n/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; 这个ThraedLocalMap 与Map类似，一个线程内可以有多个ThreadLocal类型变量，所以通过ThreadLocalMap ","wordCount":"895","inLanguage":"en","image":"https://chenyongda2018.github.io/images/profile.jpg","datePublished":"2019-04-19T20:27:16+08:00","dateModified":"2019-04-19T20:27:16+08:00","author":{"@type":"Person","name":"Petrichor"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://chenyongda2018.github.io/posts/android/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"},"publisher":{"@type":"Organization","name":"Petrichor's blog","logo":{"@type":"ImageObject","url":"https://chenyongda2018.github.io/newfav.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://chenyongda2018.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://chenyongda2018.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://chenyongda2018.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://chenyongda2018.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://chenyongda2018.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://chenyongda2018.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://chenyongda2018.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Android消息机制全面解析</h1><div class=post-meta><span title='2019-04-19 20:27:16 +0800 CST'>April 19, 2019</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;895 words&nbsp;·&nbsp;Petrichor&nbsp;|&nbsp;<a href=https://github.com/chenyongda2018/chenyongda2018.github.io/tree/main/content/posts/android/Android%e6%b6%88%e6%81%af%e6%9c%ba%e5%88%b6%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=1android消息机制概述>(1),Android消息机制概述<a hidden class=anchor aria-hidden=true href=#1android消息机制概述>#</a></h2><p>Android中的消息机制主要指 <strong>Handler的运行机制</strong> 以及 <strong>MessageQueue，Looper的工作过程</strong> ，三者相互协作，保证着消息的接收，发送，处理，执行。</p><p><img alt=" " loading=lazy src=https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a645eb49972a0d~tplv-t2oaga2asx-image.image></p><blockquote><p>​ 图片来自郭神的《第一行代码》</p></blockquote><p>先简单的介绍一下 Android 中 消息机制大家庭的主要成员 :</p><ul><li><p><strong>Handler</strong> : 是Android消息机制的上层接口，最为大家常用，相当于Android消息机制的入口，我们通过使用<code>Handler</code>发送消息来引起消息机制的循环。通常用于:在子线程执行完耗时任务完后，更新UI。</p></li><li><p><strong>MessageQueue</strong> : 存储 <strong>消息(Message)</strong> 对象的消息队列，实则是单链表结构.</p></li><li><p><strong>Looper</strong> : 用于无限的从 <code>MessageQueue</code>中取出消息，相当于消息的永动机，如果有新的消息，则处理执行，若没有，则就一直等待，堵塞。Looper** 所在的线程是 创建 <code>Handler</code> 时所在的线程。</p><p>主线程创建Handler时，会自动创建一个Looper,<strong>但是子线程并不会自动创建Looper</strong></p></li><li><p><strong>ThreadLocal</strong> : 在每个线程互不干扰的存储，提供数据，以此来获取当前线程的<code>Looper</code></p></li><li><p><strong>ActivityThread</strong> : Android 的主线程，也叫UI线程，主线程被创建时 自动初始化主线程的 <code>Looper</code>对象。</p></li></ul><h4 id=问题--大家都知道只有在ui线程才能对ui元素进行操作在子线程更改ui就会报错为什么>问题 : 大家都知道只有在UI线程才能对UI元素进行操作，在子线程更改UI就会报错，为什么？<a hidden class=anchor aria-hidden=true href=#问题--大家都知道只有在ui线程才能对ui元素进行操作在子线程更改ui就会报错为什么>#</a></h4><p>看完<a href=https://book.douban.com/subject/26599538/>《Android艺术开发探索》</a> 这本书的第10章之后我也才明白</p><ol><li>Android中的UI控件不是线程安全的，如果在子线程中也能修改UI元素，那多线程的时，共同访问同一个UI元素，就会导致这个UI元素处于我们不可预知的状态，这个线程让它往左一点，那个线程让它往右一点，UI该听谁的，好tm乱。。 干脆我就只听主线程的把。</li></ol><h4 id=问题--那为什么不通过对访问ui控件的子线程加上锁机制呢->问题 : 那为什么不通过对访问UI控件的子线程加上锁机制呢 ？<a hidden class=anchor aria-hidden=true href=#问题--那为什么不通过对访问ui控件的子线程加上锁机制呢->#</a></h4><p>这个很简单了，如果为不同的线程访问同一UI元素加上锁机制，那我们程序员写相关代码的时候会变得超级麻烦。。。 改个UI还得考虑它是不是已经被别的线程占用了，被占用了，还得让那个线程释放锁。。。线程再多一点的话，大大地加大了程序员地工作量.</p><p>而且加上锁机制无疑会由于线程堵塞地原因降低访问UI的效率，帧率降低，体验也会不友好。</p><p>让UI元素只能再主线程访问就会省下很多事，创建一个<code>Handler</code>就行了。</p><p>下面从整体概述一下 消息机制的整个工作过程 :</p><ol><li><p><code>Handler </code>创建时会采用当前线程的 <code>Looper</code>来构建内部的消息循环系统，如果Handler在子线程，则一开始是没有<code>Looper</code>对象的(解决方法稍后介绍)，主线程<code>ActivityThread</code>默认有一个Looper。</p></li><li><p><code>Handler</code>创建完毕，通过 <code>post</code>方法传入<code>Runnable</code>对象，或者通过<code>sendMessage(Message msg)</code>发送消息。</p><p><code>post()</code>方法里也是通过调用<code>send()</code>实现的</p></li><li><p><code>send()</code>方法被调用后，调用 MessageQueue的enqueueMessage()方法将消息发送到消息队列中，等待被处理。</p></li><li><p><code>Looper</code>对象运行在<code>Handler</code>所在的线程，从<code>MessageQueue消息队列</code>中不断地取出消息，处理，所以业务逻辑(通常是更新UI)就运行在Looper的线程中。</p></li></ol><h3></h3><p>接下来从局部来分析消息机制的每个成员。</p><h2 id=2threadlocal-工作原理>(2),ThreadLocal 工作原理<a hidden class=anchor aria-hidden=true href=#2threadlocal-工作原理>#</a></h2><h4 id=1-什么是threadlocal>1, 什么是ThreadLocal？<a hidden class=anchor aria-hidden=true href=#1-什么是threadlocal>#</a></h4><p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中获得存储数据，获得数据，线程之间的ThreadLocal相互独立，且无法获得另一个线程的TheadLocal.</p><ul><li><p>相对整个程序来说，每个线程的ThreadLocal是局部变量。</p></li><li><p>相对一个线程来说，线程内的ThreadLocal是线程的全局变量</p></li></ul><p>ThreadLocal是一个泛型类，可以存储任意类型的对象。</p><p>示例:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ThreadLocalTest</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span><span class=w> </span><span class=n>mThreadLocal</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>mThreadLocal</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;#Main Thread : ThreadLocal &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>mThreadLocal</span><span class=p>.</span><span class=na>get</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		
</span></span></span><span class=line><span class=cl><span class=w>		
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>mThreadLocal</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;#1 Thread : ThreadLocal &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>mThreadLocal</span><span class=p>.</span><span class=na>get</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;#2 Thread : ThreadLocal &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>mThreadLocal</span><span class=p>.</span><span class=na>get</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>我们在主线程创建一个 泛型为<code>Boolean</code>的ThreadLocal，并<code>.set(True)</code>,然后在第一个子线程中<code>.set(False)</code>，在第二个子线程中不做修改，直接打印。 可以看到，在不同的线程中获得的值也不同。</p><p>输出 :</p><pre tabindex=0><code>#Main Thread : ThreadLocal true
#1 Thread : ThreadLocal false
#2 Thread : ThreadLocal null
</code></pre><h4 id=2threadlocal的实现原理>2，ThreadLocal的实现原理<a hidden class=anchor aria-hidden=true href=#2threadlocal的实现原理>#</a></h4><p>首先每个线程内部都维护着一个<code>ThreadLocalMap</code>对象</p><p><em>Thread.Java</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/* ThreadLocal values pertaining to this thread. This map is maintained
</span></span></span><span class=line><span class=cl><span class=cm> * by the ThreadLocal class. */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ThreadLocal</span><span class=p>.</span><span class=na>ThreadLocalMap</span><span class=w> </span><span class=n>threadLocals</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>这个ThraedLocalMap 与Map类似，一个线程内可以有多个ThreadLocal类型变量，所以通过<code>ThreadLocalMap &lt;ThreadLocal&lt;?> key, Object value></code>.保存着多个&lt;ThreadLocal , 任意类型对象>键值对。</p><p>看一下ThreadLocal的<code>set()</code>方法实现 :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Sets the current thread&#39;s copy of this thread-local variable
</span></span></span><span class=line><span class=cl><span class=cm>     * to the specified value.  Most subclasses will have no need to
</span></span></span><span class=line><span class=cl><span class=cm>     * override this method, relying solely on the {@link #initialValue}
</span></span></span><span class=line><span class=cl><span class=cm>     * method to set the values of thread-locals.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param value the value to be stored in the current thread&#39;s copy of
</span></span></span><span class=line><span class=cl><span class=cm>     *        this thread-local.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>set</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ThreadLocalMap</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getMap</span><span class=p>(</span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>map</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>map</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>else</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>createMap</span><span class=p>(</span><span class=n>t</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>先是获得当前线程的<code>ThreadLocalMap</code>对象，map.set(this,value) 设置了我这个ThreadLocal存储的值.</p><p><code>get()</code>方法实现 :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Returns the value in the current thread&#39;s copy of this
</span></span></span><span class=line><span class=cl><span class=cm>     * thread-local variable.  If the variable has no value for the
</span></span></span><span class=line><span class=cl><span class=cm>     * current thread, it is first initialized to the value returned
</span></span></span><span class=line><span class=cl><span class=cm>     * by an invocation of the {@link #initialValue} method.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @return the current thread&#39;s value of this thread-local
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=nf>get</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>();</span><span class=c1>//获得当前线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ThreadLocalMap</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getMap</span><span class=p>(</span><span class=n>t</span><span class=p>);</span><span class=c1>//根据根据获得它的ThreadLocalMap</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>map</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ThreadLocalMap</span><span class=p>.</span><span class=na>Entry</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>getEntry</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=c1>//获得&lt;k,v&gt;键值对</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>e</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nd>@SuppressWarnings</span><span class=p>(</span><span class=s>&#34;unchecked&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>T</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>T</span><span class=p>)</span><span class=n>e</span><span class=p>.</span><span class=na>value</span><span class=p>;</span><span class=c1>//通过&lt;k,v&gt;获得值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>setInitialValue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=3threadlocal的使用场景>3，ThreadLocal的使用场景<a hidden class=anchor aria-hidden=true href=#3threadlocal的使用场景>#</a></h4><p>一般，当某些数据是以线程为作用域，并且不同的线程具有不同的数据副本时，可以考虑用<code>ThreadLocal</code></p><h6 id=场景1>场景1:<a hidden class=anchor aria-hidden=true href=#场景1>#</a></h6><p>对于<code>Handler</code>,它想要获得当前线程的<code>Looper</code>，并且<code>Looper</code>的作用域就是当前的线程，不同的线程具有不同的<code>Looper</code>对象，这时可以使用ThreadLocal。</p><h6 id=场景2>场景2:<a hidden class=anchor aria-hidden=true href=#场景2>#</a></h6><p>复杂逻辑下的对象的传递，如果想要一个对象贯穿着整个线程的执行过程，可采用Threadlocal让此对象作为该线程的全局对象。</p><h2 id=3messagequeue的工作原理>(3),MessageQueue的工作原理<a hidden class=anchor aria-hidden=true href=#3messagequeue的工作原理>#</a></h2><p>以<strong>单链表</strong>的形式，存储着<code>Handler</code>发送过来的消息，再来一张图加深印象</p><p><img loading=lazy src=https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a645eb4989cbbf~tplv-t2oaga2asx-image.image></p><p>主要包含两个操作:</p><ul><li>通过<code>enqueueMessage(Message msg,long when)</code>，像队列插入一个消息,这里为了节省篇幅，就不上源码，贴上源码连接,<a href=http://androidxref.com/6.0.0_r1/xref/frameworks/base/core/java/android/os/MessageQueue.java#enqueueMessage>MessageQueue.enqueueMessage()</a></li><li>通过<code>next()</code>从无限循环队列中取出消息，并从消息队列中删除。<a href=http://androidxref.com/6.0.0_r1/xref/frameworks/base/core/java/android/os/MessageQueue.java#next>MessageQueue.next()</a></li></ul><p>虽然它叫做<code>消息队列</code>，但内部其实是以单链表的结构存储，有利于插入，删除的操作。</p><h2 id=4looper的工作原理>(4),Looper的工作原理<a hidden class=anchor aria-hidden=true href=#4looper的工作原理>#</a></h2><p>它的主要作用就是 不停地从消息队列中 查看是否有新的消息，如果有新的消息就会立刻处理，没有消息就会堵塞。</p><p>持有<code>MessageQueue</code>的引用，并且会在构造方法中初始化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=nf>Looper</span><span class=p>(</span><span class=kt>boolean</span><span class=w> </span><span class=n>quitAllowed</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mQueue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>MessageQueue</span><span class=p>(</span><span class=n>quitAllowed</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mThread</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=问题-如何在子线程创建它的looper对象->问题: 如何在子线程创建它的Looper对象 ?<a hidden class=anchor aria-hidden=true href=#问题-如何在子线程创建它的looper对象->#</a></h4><p>前面说到主线程自己会创建一个<code>Looper</code>对象，所以我们在主线程使用<code>Handler</code>的时候直接创建就可以了。</p><p>但是在子线程使用Handler的话，就需要我们手动创建<code>Looper</code>了，</p><p>示例:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Looper</span><span class=p>.</span><span class=na>prepare</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Handler</span><span class=w> </span><span class=n>handler</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Handler</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Looper</span><span class=p>.</span><span class=na>loop</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p><code>prepare()</code>源码如下:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w> </span><span class=cm>/** Initialize the current thread as a looper.
</span></span></span><span class=line><span class=cl><span class=cm>77      * This gives you a chance to create handlers that then reference
</span></span></span><span class=line><span class=cl><span class=cm>78      * this looper, before actually starting the loop. Be sure to call
</span></span></span><span class=line><span class=cl><span class=cm>79      * {@link #loop()} after calling this method, and end it by calling
</span></span></span><span class=line><span class=cl><span class=cm>80      * {@link #quit()}.
</span></span></span><span class=line><span class=cl><span class=cm>81      */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>82</span><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>prepare</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>83</span><span class=w>        </span><span class=nf>prepare</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>84</span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>85</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>86</span><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>prepare</span><span class=p>(</span><span class=kt>boolean</span><span class=w> </span><span class=n>quitAllowed</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>87</span><span class=w>        </span><span class=nf>if</span><span class=w> </span><span class=p>(</span><span class=n>sThreadLocal</span><span class=p>.</span><span class=na>get</span><span class=p>()</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>88</span><span class=w>            </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=nf>RuntimeException</span><span class=p>(</span><span class=s>&#34;Only one Looper may be created per thread&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>89</span><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>90</span><span class=w>        </span><span class=n>sThreadLocal</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Looper</span><span class=p>(</span><span class=n>quitAllowed</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>91</span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>可以看到最终是调用了 此 Looper 所在线程的 **ThreadLocal.set()**方法，存了一个Looper对象进去。</p><p>除了<code>prepare()</code>，还有一些其他方法，我们也需要知道</p><ul><li><p><strong>loop()</strong> : 启动消息循环，，只有当Looper调用了loop()之后，整个消息循环才活了起来</p></li><li><p><strong>prepareMainLooper()</strong> : 给主线程创建Looper对象</p></li><li><p><strong>getMainLooper()</strong> : 获得主线程的Looper对象</p></li><li><p><strong>quit()</strong> : 通知消息队列，直接退出消息循环，不等待当前正在处理的消息执行完，quit之后，再向消息队列中发送新的消息就会失败( Handler的send()方法就会返回false )</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w> </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>quit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>mQueue</span><span class=p>.</span><span class=na>quit</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p><strong>quitSafety()</strong> : 通过消息队列，不再接收新的消息，等当前的消息队列中的消息处理完就退出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w> </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>quitSafely</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mQueue</span><span class=p>.</span><span class=na>quit</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>    
</span></span></span></code></pre></div></li></ul><p>下面分析<code>loop()</code>的实现:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>119     * Run the message queue in this thread. Be sure to call
</span></span></span><span class=line><span class=cl><span class=cm>120     * {@link #quit()} to end the loop.
</span></span></span><span class=line><span class=cl><span class=cm>121     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>122</span><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>loop</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>123</span><span class=w>        </span><span class=kd>final</span><span class=w> </span><span class=n>Looper</span><span class=w> </span><span class=n>me</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>myLooper</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>124</span><span class=w>        </span><span class=nf>if</span><span class=w> </span><span class=p>(</span><span class=n>me</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>125</span><span class=w>            </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=nf>RuntimeException</span><span class=p>(</span><span class=s>&#34;No Looper; Looper.prepare() wasn&#39;t called on                                            this thread.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>126</span><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>127</span><span class=w>        </span><span class=kd>final</span><span class=w> </span><span class=n>MessageQueue</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>me</span><span class=p>.</span><span class=na>mQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>128</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>129</span><span class=w>        </span><span class=p>...</span><span class=c1>//省略部分代码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>133</span><span class=w>		  </span><span class=c1>//从这里开启无限循环，直到 没有消息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>134</span><span class=w>        </span><span class=nf>for</span><span class=w> </span><span class=p>(;;)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>135</span><span class=w>            </span><span class=n>Message</span><span class=w> </span><span class=n>msg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>queue</span><span class=p>.</span><span class=na>next</span><span class=p>();</span><span class=w> </span><span class=c1>// might block</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>136</span><span class=w>            </span><span class=nf>if</span><span class=w> </span><span class=p>(</span><span class=n>msg</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>137</span><span class=w>                </span><span class=c1>// No message indicates that the message queue is quitting.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>138</span><span class=w>                </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>139</span><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>140</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>141</span><span class=w>            </span><span class=c1>// This must be in a local variable, in case a UI event sets the logger</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>142</span><span class=w>            </span><span class=n>Printer</span><span class=w> </span><span class=n>logging</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>me</span><span class=p>.</span><span class=na>mLogging</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>143</span><span class=w>            </span><span class=nf>if</span><span class=w> </span><span class=p>(</span><span class=n>logging</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>144</span><span class=w>                </span><span class=n>logging</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;&gt;&gt;&gt;&gt;&gt; Dispatching to &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>msg</span><span class=p>.</span><span class=na>target</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; &#34;</span><span class=w> </span><span class=o>+</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>145</span><span class=w>                        </span><span class=n>msg</span><span class=p>.</span><span class=na>callback</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>msg</span><span class=p>.</span><span class=na>what</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>146</span><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>147</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>148</span><span class=w>            </span><span class=n>msg</span><span class=p>.</span><span class=na>target</span><span class=p>.</span><span class=na>dispatchMessage</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>149</span><span class=w>			   </span><span class=p>...</span><span class=c1>//省略部分代码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>166</span><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>167</span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在 for 循环里 :</p><ol><li>通过queue.next()一直读取新的消息，如果没有消息 则退出循环。</li><li>接下来，<code> msg.target.dispatchMessage(msg);</code>，target是发送此消息的 Hander对像，通知Handler调用<code>dispatchMessage()</code>来接收消息。</li></ol><h2 id=5handler的工作原理>(5),Handler的工作原理<a hidden class=anchor aria-hidden=true href=#5handler的工作原理>#</a></h2><p>Handler的主要工作就是 发送消息，接收消息。</p><p>发送消息的方式有post(),send(),不过post()方法最后还是调用的send()方法</p><ul><li><p><strong>发送消息的过程</strong>:</p><p>send类型的发送消息方法有很多，并且是嵌套的</p><p><em>sendMessage()</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>sendMessage</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>msg</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>sendMessageDelayed</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><em>sendMessageDelayed()</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>sendMessageDelayed</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>msg</span><span class=p>,</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>delayMillis</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>delayMillis</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>delayMillis</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>sendMessageAtTime</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span><span class=w> </span><span class=n>SystemClock</span><span class=p>.</span><span class=na>uptimeMillis</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>delayMillis</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><em>sendMessageAtTime()</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w> </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>sendMessageAtTime</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>msg</span><span class=p>,</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>uptimeMillis</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>MessageQueue</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mQueue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>queue</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>RuntimeException</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>this</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; sendMessageAtTime() called with no mQueue&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Log</span><span class=p>.</span><span class=na>w</span><span class=p>(</span><span class=s>&#34;Looper&#34;</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>.</span><span class=na>getMessage</span><span class=p>(),</span><span class=w> </span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>enqueueMessage</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span><span class=w> </span><span class=n>msg</span><span class=p>,</span><span class=w> </span><span class=n>uptimeMillis</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>三种send的发送消息方式，最后都会通过<code>enqueueMessage()</code>来通知消息队列 插入这条新的消息。</p><p><em>Handler.enqueueMessage</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>enqueueMessage</span><span class=p>(</span><span class=n>MessageQueue</span><span class=w> </span><span class=n>queue</span><span class=p>,</span><span class=w> </span><span class=n>Message</span><span class=w> </span><span class=n>msg</span><span class=p>,</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>uptimeMillis</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>msg</span><span class=p>.</span><span class=na>target</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mAsynchronous</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>           </span><span class=n>msg</span><span class=p>.</span><span class=na>setAsynchronous</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=n>queue</span><span class=p>.</span><span class=na>enqueueMessage</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span><span class=w> </span><span class=n>uptimeMillis</span><span class=p>);</span><span class=c1>//调用消息队列的enqueueMessage()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p><strong>接收消息的过程</strong></p><p>接收消息由<code>dispatchMessage(Message msg)</code>为入口</p><p><em>dispatchMessage()</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>dispatchMessage</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>msg</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>msg</span><span class=p>.</span><span class=na>callback</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>handleCallback</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mCallback</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>mCallback</span><span class=p>.</span><span class=na>handleMessage</span><span class=p>(</span><span class=n>msg</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                   </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>handleMessage</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>这里的<code>callback</code>是我们调用 post(Runnable runnalbe) 时传入的<code>Runnable</code>对象，如果我们传入了<code>Runnable</code>对象</p><p>就会执行<code>Runnable的</code>run方法:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>handleCallback</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>message</span><span class=p>.</span><span class=na>callback</span><span class=p>.</span><span class=na>run</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>如果没有通过<code>post</code>传<code>Runnable</code>，就会看创建Handler时的构造方法中有没有传<code>Runnable</code>参数，传了的话由<code>mCallback</code>存储。</p><p>这个<code>mCallback</code>是Handler内部的一个接口</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>Callback</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>handleMessage</span><span class=p>(</span><span class=n>Message</span><span class=w> </span><span class=n>msg</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>如果构造Handler时也没有传<code>Runnable</code>对象，最终会执行<code>handleMessage(msg)</code>,这个 方法就是我们创建handler时重写的handleMessage()方法.</p><p><img loading=lazy src=https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a645eb4972d252~tplv-t2oaga2asx-image.image></p></li></ul><hr><p>参考资料: <a href=https://book.douban.com/subject/26599538/>Android艺术开发探索</a></p><p><a href=https://www.cnblogs.com/luxiaoxun/p/8744826.html>https://www.cnblogs.com/luxiaoxun/p/8744826.html</a></p><p>(完~)</p><p><img loading=lazy src=https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a645eb499d0c8f~tplv-t2oaga2asx-image.image></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://chenyongda2018.github.io/tags/android/>Android</a></li><li><a href=https://chenyongda2018.github.io/tags/handler/>Handler</a></li></ul><nav class=paginav><a class=prev href=https://chenyongda2018.github.io/posts/android/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8android%E4%B8%AD%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E7%9A%84ocr%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%8F%E5%8E%86/><span class=title>« Prev</span><br><span>记一次在Android中调用百度的OCR接口的经历</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Android消息机制全面解析 on x" href="https://x.com/intent/tweet/?text=Android%e6%b6%88%e6%81%af%e6%9c%ba%e5%88%b6%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90&amp;url=https%3a%2f%2fchenyongda2018.github.io%2fposts%2fandroid%2fandroid%25E6%25B6%2588%25E6%2581%25AF%25E6%259C%25BA%25E5%2588%25B6%25E5%2585%25A8%25E9%259D%25A2%25E8%25A7%25A3%25E6%259E%2590%2f&amp;hashtags=Android%2cHandler"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android消息机制全面解析 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fchenyongda2018.github.io%2fposts%2fandroid%2fandroid%25E6%25B6%2588%25E6%2581%25AF%25E6%259C%25BA%25E5%2588%25B6%25E5%2585%25A8%25E9%259D%25A2%25E8%25A7%25A3%25E6%259E%2590%2f&amp;title=Android%e6%b6%88%e6%81%af%e6%9c%ba%e5%88%b6%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90&amp;summary=Android%e6%b6%88%e6%81%af%e6%9c%ba%e5%88%b6%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90&amp;source=https%3a%2f%2fchenyongda2018.github.io%2fposts%2fandroid%2fandroid%25E6%25B6%2588%25E6%2581%25AF%25E6%259C%25BA%25E5%2588%25B6%25E5%2585%25A8%25E9%259D%25A2%25E8%25A7%25A3%25E6%259E%2590%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android消息机制全面解析 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fchenyongda2018.github.io%2fposts%2fandroid%2fandroid%25E6%25B6%2588%25E6%2581%25AF%25E6%259C%25BA%25E5%2588%25B6%25E5%2585%25A8%25E9%259D%25A2%25E8%25A7%25A3%25E6%259E%2590%2f&title=Android%e6%b6%88%e6%81%af%e6%9c%ba%e5%88%b6%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android消息机制全面解析 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fchenyongda2018.github.io%2fposts%2fandroid%2fandroid%25E6%25B6%2588%25E6%2581%25AF%25E6%259C%25BA%25E5%2588%25B6%25E5%2585%25A8%25E9%259D%25A2%25E8%25A7%25A3%25E6%259E%2590%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android消息机制全面解析 on whatsapp" href="https://api.whatsapp.com/send?text=Android%e6%b6%88%e6%81%af%e6%9c%ba%e5%88%b6%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90%20-%20https%3a%2f%2fchenyongda2018.github.io%2fposts%2fandroid%2fandroid%25E6%25B6%2588%25E6%2581%25AF%25E6%259C%25BA%25E5%2588%25B6%25E5%2585%25A8%25E9%259D%25A2%25E8%25A7%25A3%25E6%259E%2590%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android消息机制全面解析 on telegram" href="https://telegram.me/share/url?text=Android%e6%b6%88%e6%81%af%e6%9c%ba%e5%88%b6%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90&amp;url=https%3a%2f%2fchenyongda2018.github.io%2fposts%2fandroid%2fandroid%25E6%25B6%2588%25E6%2581%25AF%25E6%259C%25BA%25E5%2588%25B6%25E5%2585%25A8%25E9%259D%25A2%25E8%25A7%25A3%25E6%259E%2590%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Android消息机制全面解析 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Android%e6%b6%88%e6%81%af%e6%9c%ba%e5%88%b6%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90&u=https%3a%2f%2fchenyongda2018.github.io%2fposts%2fandroid%2fandroid%25E6%25B6%2588%25E6%2581%25AF%25E6%259C%25BA%25E5%2588%25B6%25E5%2585%25A8%25E9%259D%25A2%25E8%25A7%25A3%25E6%259E%2590%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://chenyongda2018.github.io/>Petrichor's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>