[{"content":"EventBus是一个消息订阅/发布的开源框架。\n如上图所示 , EventBus框架中主要有2个角色 :\nPublisher : 发布消息的, 被观察者 Subscriber : 接收消息的 , 观察者 Publisher(被观察者) 通过 post() 将一个事件/消息(Event) 发送到事件的集中地,也就是图中的 EventBus ，EventBus 再将事件/消息(Event)发给Subcriber观察者。\n使用这样的框架，能够使Activity/Fragment等组件之间的通信简化 , 不用再像以前一直使用 intent 来传送数据 , 从而提升开发效率。\n1.配置依赖 在app层的 build.gradle 中添加 :\nimplementation \u0026#39;org.greenrobot:eventbus:3.1.1\u0026#39; 2.初步使用 根据官方文档 , 首先要定义一个Event(消息)的POJO类 :\npublic class MessageEvent { private String message ; public MessageEvent(String message) { this.message = message; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } } 然后 , 我们要明确哪个组件是 Subsriber(观察者), 哪个组件是Publisher(被观察者) , 在这里 , 我们通过EventBus演示一个传送消息的demo。\n首先 , 观察者要注册EventBus , 在这里 因为当前活动就是接收消息的,所以当前活动就是 观察者(接收事件的一方) ,\n并且用 @Subscribe 注解定义一个处理接收事件的方法 ， 这里我们简单地把收到的事件内容用Toast弹出。\npublic class ToastActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_toast); //注册 EventBus.getDefault().register(this); } @Override protected void onDestroy() { //解除注册 EventBus.getDefault().unregister(this); super.onDestroy(); } /** * 接收事件 * @param msg */ @Subscribe public void onMessageEvent(Message msg) { Toast.makeText(this, msg.getMessage(), Toast.LENGTH_SHORT).show(); } } 最后 , 我们要实现点击按钮,通过EventBus发送事件 , 所以当前活动也作为被 观察者(发送事件的一方) , 发送消息通过 post() 即可。\npublic class ToastActivity extends AppCompatActivity { EditText mMsgEt; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_toast); EventBus.getDefault().register(this); mMsgEt = (EditText) findViewById(R.id.message_et); findViewById(R.id.send_msg_btn).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //发送事件 EventBus.getDefault().post(new Message(mMsgEt.getText().toString())); } }); } /** * 接收事件 * @param msg */ @Subscribe public void onMessageEvent(Message msg) { Toast.makeText(this, msg.getMessage(), Toast.LENGTH_SHORT).show(); } @Override protected void onDestroy() { EventBus.getDefault().unregister(this); super.onDestroy(); } } 3.ThreadMode 在EventBus中, 我们可以设置观察者处理接收到消息的函数所在的线程。\n1.ThreadMode.POSTING @Subscribe(threadMode = ThreadMode.POSTING) public void onMessage(MessageEvent event) { log(event.message); } 这是eventBus的默认模式 , 接收消息的函数会在发送消息所在的线程中被调用。这种模式下避免了发送事件和处理事件间的线程切换，开销最小。\n但是当发送事件在主线程时，应避免处理事件的函数发生堵塞，否则会引起卡顿。\n2.ThreadMode.MAIN @Subscribe(threadMode = ThreadMode.MAIN) public void onMessage(MessageEvent event) { log(event.message); } 这种模式下处理事件的函数将在主线程中执行 , 所以也应该避免在处理函数中发生堵塞。\n3.ThreadMode.MAIN_ORDERED @Subscribe(threadMode = ThreadMode.MAIN_ORDERED) public void onMessage(MessageEvent event) { log(event.message); } 这种模式下 , 事件的处理函数不仅在主线程 , 当有被观察者发送了多个事件的时候 , 事件将按照发送的顺序依次被处理 , 保证了事件之间的顺序性。\n4.TheadMode.BACKGROUND @Subscribe(threadMode = ThreadMode.BACKGROUND) public void onMessage(MessageEvent event) { log(event.message); } 当发送事件所在线程是子线程 , 则事件也在统一子线程处理。\n当发送事件所在线程是主线车工 , 则eventBus会在后台新开一个线程调用事件处理函数。\n5.ThreadMode.ASYNC @Subscribe(threadMode = ThreadMode.ASYNC) public void onMessage(MessageEvent event) { log(event.message); } 在此模式下 , 事件处理函数始终在与发送事件所在线程之外的子线程中执行 , 也就是两者所在线程相互独立。\n4.粘性事件 普通的事件需要接收方先注册,发送方再发送消息,才能完成消息的发送和处理。\n而粘性事件的作用就是,发送方可以先发送事件 , 接收方在之后进行注册时再完成消息的处理。\n1.简单使用 现在我们做一个注册-\u0026gt;登陆流程的demo ,我们想要实现 :\n用户首先在注册页面填写账号\u0026amp;密码信息 , 再进入登陆页面时, 就不用再重复输入账号密码了。\n效果图 :\n代码 :\n注册页面 :\npublic class RegisterActivity extends AppCompatActivity { EditText mUsernameEditText;//用户名编辑框 EditText mPasswordEditText;//密码编辑框 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_register); mUsernameEditText = (EditText) findViewById(R.id.register_username_text_input_layout); mPasswordEditText = (EditText) findViewById(R.id.register_activity_password_et); //点击注册 findViewById(R.id.register_btn).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String username = mUsernameEditText.getText().toString(); String password = mPasswordEditText.getText().toString(); Toast.makeText(RegisterActivity.this, \u0026#34;注册成功 , 快去登陆~\u0026#34;, Toast.LENGTH_SHORT).show(); //发送粘性事件 EventBus.getDefault().postSticky(new MessageEvent(username,password)); startActivity(new Intent(RegisterActivity.this, LoginActivity.class)); } }); } } 通过 postSticky() 发送一个粘性事件。\n登陆页面 :\npublic class LoginActivity extends AppCompatActivity { EditText mUsernameEd;//用户名编辑框 EditText mPasswordEd;//密码编辑框 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); EventBus.getDefault().register(this); mUsernameEd = (EditText)findViewById(R.id.login_username_text_input_layout); mPasswordEd = (EditText)findViewById(R.id.login_password_editText); } //接收粘性事件 , 将注册页面的信息赋值到编辑框中 @Subscribe(sticky = true) public void onEvent(MessageEvent event) { mUsernameEd.setText(event.getUsername()); mPasswordEd.setText(event.getPassword()); } @Override protected void onDestroy() { EventBus.getDefault().unregister(this); super.onDestroy(); } } 2. 获取/移除粘性消息 当我们发送了一个粘性消息 , 但这个消息尚未被订阅者接收处理时 , 我们可以通过 getStickyEvent() 拿到这个消息。\n//获取已经发送的但未处理的粘性消息 MessageEvent stickyEvent = EventBus.getDefault().getStickyEvent(MessageEvent.class); 并且可以通过 removeStickyEvent() 移除这个事件 , 这样之后订阅之注册之后也不会收到这个事件。\n//移除消息 EventBus.getDefault().removeStickyEvent(stickyEvent); 现在试验一下, 我们在前面的demo中进行修改 , 在注册页面点击注册按钮时 , 移除粘性事件。\npublic class RegisterActivity extends AppCompatActivity { ... @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_register); ... findViewById(R.id.register_btn).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String username = mUsernameEditText.getText().toString(); String password = mPasswordEditText.getText().toString(); //发送粘性消息 EventBus.getDefault().postSticky(new MessageEvent(username, password)); //获取已经发送的但未处理的粘性消息 MessageEvent stickyEvent = EventBus.getDefault().getStickyEvent(MessageEvent.class); if (stickyEvent != null) { //移除消息 EventBus.getDefault().removeStickyEvent(stickyEvent); } startActivity(new Intent(RegisterActivity.this, LoginActivity.class)); } }); } } 这样 , 在跳转到登陆页面时 , 自动填充用户名\u0026amp;密码的效果就消失了。\n5.源码学习 在看EventBus源码之前 , 要先想清楚我们想要得到什么反馈 , 看源码能弄明白什么问题。\nEventBus是如何实现订阅者在事件到来时执行对应方法的 , 在register(),post()时发生了什么？ EventBus.getDefault().register(this); 1.register() : public void register(Object subscriber) { //1.获得订阅者(Activity,fragment)的Class对象 Class\u0026lt;?\u0026gt; subscriberClass = subscriber.getClass(); //2.根据订阅者的Class对象查找它用@Subcribe注解的方法集合 , 对于SubcriberMethodFinder的类暂时先不用管 List\u0026lt;SubscriberMethod\u0026gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) { //3.将Class对象与它里面的@Subcribe方法进行注册绑定 for (SubscriberMethod subscriberMethod : subscriberMethods) { subscribe(subscriber, subscriberMethod); } } } register()方法中做了3件事情 :\n获得订阅者(Activity,fragment)的Class对象 根据订阅者的Class对象查找它用@Subcribe注解的方法集合 将Class对象与它里面的@Subcribe方法进行注册绑定 ##subcribe()方法 : 在注释中已经写清楚代码的作用 , 按照顺序阅读应该很容易理解。\n/** * @param subscriber 订阅者(Activity,fragment等组件)的Class对象 * @param subscriberMethod 订阅者中用@Subcribe注解的方法 */ private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) { //1.获得订阅方法所对应的Event类型 Class\u0026lt;?\u0026gt; eventType = subscriberMethod.eventType; //2.将订阅者和订阅方法打包到一个包装类 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //3.获得这个Event所有的\u0026lt;订阅者,订阅方法\u0026gt;集合，集合中也可能包含参数中订阅者以外的订阅者 CopyOnWriteArrayList\u0026lt;Subscription\u0026gt; subscriptions = subscriptionsByEventType.get(eventType); //4.若\u0026lt;订阅者,订阅方法\u0026gt;集合为空 , 说明接收该Event的若干组件还未调用register() if (subscriptions == null) { subscriptions = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); subscriptionsByEventType.put(eventType, subscriptions); } else { //5.如果这个Event对应的的\u0026lt;订阅者,订阅方法\u0026gt;集合中已经包含了当前这个\u0026lt;订阅者,订阅方法\u0026gt;，则说明当前组件重复调用register()了. if (subscriptions.contains(newSubscription)) { throw new EventBusException(\u0026#34;Subscriber \u0026#34; + subscriber.getClass() + \u0026#34; already registered to event \u0026#34; + eventType); } } int size = subscriptions.size(); //6.将订阅方法按照优先级大小排序 for (int i = 0; i \u0026lt;= size; i++) { if (i == size || subscriberMethod.priority \u0026gt; subscriptions.get(i).subscriberMethod.priority) { subscriptions.add(i, newSubscription); break; } } //7.获取这个订阅者订阅的所有Event集合 List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) { subscribedEvents = new ArrayList\u0026lt;\u0026gt;(); typesBySubscriber.put(subscriber, subscribedEvents); } //8.将当前@Subcribe方法的Event类型添加到这个订阅者的Event集合中 subscribedEvents.add(eventType); //9.如果@Subcribe()方法中sticky = true ,则获得这个粘性事件 //注意如果当前事件是普通事件 , 则不做任何处理。 if (subscriberMethod.sticky) { if (eventInheritance) { Set\u0026lt;Map.Entry\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt;\u0026gt; entries = stickyEvents.entrySet(); for (Map.Entry\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; entry : entries) { //先获得粘性事件Event的Class对象 Class\u0026lt;?\u0026gt; candidateEventType = entry.getKey(); //找到当前Subscribe()方法订阅的粘性事件 if (eventType.isAssignableFrom(candidateEventType)) { //得到粘性事件 Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); } } } else { Object stickyEvent = stickyEvents.get(eventType); //10.对sticky事件判空,并执行订阅方法 checkPostStickyEventToSubscription(newSubscription, stickyEvent); } } } 看一下第10步的方法 checkPostStickyEventToSubsctiption() :\n/** * 对事件进行判空 * @param newSubscription (订阅者,订阅方法) * @param stickyEvent 粘性事件 */ private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) { if (stickyEvent != null) { // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state) // --\u0026gt; Strange corner case, which we don\u0026#39;t take care of here. postToSubscription(newSubscription, stickyEvent, isMainThread()); } } ##postToSubscription() :\nprivate void postToSubscription(Subscription subscription, Object event, boolean isMainThread) { //根据对应的ThreadMode,在对应的线程中执行 switch (subscription.subscriberMethod.threadMode) { case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) { invokeSubscriber(subscription, event); } else { mainThreadPoster.enqueue(subscription, event); } break; case MAIN_ORDERED: if (mainThreadPoster != null) { mainThreadPoster.enqueue(subscription, event); } else { // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); } break; case BACKGROUND: if (isMainThread) { backgroundPoster.enqueue(subscription, event); } else { invokeSubscriber(subscription, event); } break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\u0026#34;Unknown thread mode: \u0026#34; + subscription.subscriberMethod.threadMode); } } 这个方法根据对应的ThreadMode,在对应的线程中调用 invokeSubcriber() 方法 , 这个方法就是让粘性事件的@Subcriber注解的方法执行的地方 :\n##invokeSubcriber() :\n/** * 通过反射调用订阅者中的@Subcribe方法 * @param subscription * @param event */ void invokeSubscriber(Subscription subscription, Object event) { try { // subscription.subscriberMethod.method.invoke(subscription.subscriber, event); } catch (InvocationTargetException e) { handleSubscriberException(subscription, event, e.getCause()); } catch (IllegalAccessException e) { throw new IllegalStateException(\u0026#34;Unexpected exception\u0026#34;, e); } } 从以上流程可以看出 订阅者调用了 register() 之后 ,对粘性事件的处理情况 , 流程图如下 :\n那么普通事件是如何处理的呢 ?\n我们看一下 post() 方法做了什么 :\n2.post() /** * Posts the given event to the event bus. */ public void post(Object event) { //获取当前线程的发送状态 PostingThreadState postingState = currentPostingThreadState.get(); //获取当前线程的事件序列 List\u0026lt;Object\u0026gt; eventQueue = postingState.eventQueue; //把事件添加到序列中 eventQueue.add(event); //如果当前线程尚未处于发送状态 if (!postingState.isPosting) { postingState.isMainThread = isMainThread(); //标志当前线程处于发送事件状态 postingState.isPosting = true; //正处于发送状态时是不能取消的 if (postingState.canceled) { throw new EventBusException(\u0026#34;Internal error. Abort state was not reset\u0026#34;); } try { //将事件序列中的事件挨个发送 while (!eventQueue.isEmpty()) { postSingleEvent(eventQueue.remove(0), postingState); } } finally { postingState.isPosting = false; postingState.isMainThread = false; } } } EventBus中用ThreadLocal存储了每个线程的发送状态 ,\nprivate final ThreadLocal\u0026lt;PostingThreadState\u0026gt; currentPostingThreadState = new ThreadLocal\u0026lt;PostingThreadState\u0026gt;() { @Override protected PostingThreadState initialValue() { return new PostingThreadState(); } }; ThreadLocal这个类是线程独立的 ， 能够保证每个线程之间的发送状态互不干扰。\n进入最后发送事件的函数 postSingleEvent() :\nprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error { Class\u0026lt;?\u0026gt; eventClass = event.getClass(); boolean subscriptionFound = false; //是否开启了事件继承 if (eventInheritance) { //寻找当前事件类的素有父类,接口 List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h \u0026lt; countTypes; h++) { Class\u0026lt;?\u0026gt; clazz = eventTypes.get(h); //有多个订阅者时,只要有一个发送成功,则左边为true subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); } } else { //发送单个事件 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); } //如果当前事件还没有订阅者订阅 if (!subscriptionFound) { if (logNoSubscriberMessages) { logger.log(Level.FINE, \u0026#34;No subscribers registered for event \u0026#34; + eventClass); } if (sendNoSubscriberEvent \u0026amp;\u0026amp; eventClass != NoSubscriberEvent.class \u0026amp;\u0026amp; eventClass != SubscriberExceptionEvent.class) { //发送一个没有订阅者的事件，这个事件可以由我们来接收 post(new NoSubscriberEvent(this, event)); } } } 进入 postSingleEventForEventType() :\nprivate boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class\u0026lt;?\u0026gt; eventClass) { CopyOnWriteArrayList\u0026lt;Subscription\u0026gt; subscriptions; //获取订阅了这个事件的\u0026lt;订阅者,订阅方法\u0026gt;列表 synchronized (this) { subscriptions = subscriptionsByEventType.get(eventClass); } //如果这个事件有订阅者 if (subscriptions != null \u0026amp;\u0026amp; !subscriptions.isEmpty()) { for (Subscription subscription : subscriptions) { postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try { //将事件分发给订阅者 , 在分析register()时分析过。 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; } finally { postingState.event = null; postingState.subscription = null; postingState.canceled = false; } if (aborted) { break; } } return true; } return false; } 可以看到,最后的把事件发送给订阅者的函数 postToSubcription() 与 register() 流程中最后发送粘性事件给订阅者的一样 , 这里就不介绍了。\nprivate void postToSubscription(Subscription subscription, Object event, boolean isMainThread) { //根据对应的ThreadMode,在对应的线程中执行 switch (subscription.subscriberMethod.threadMode) { case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) { invokeSubscriber(subscription, event); } else { mainThreadPoster.enqueue(subscription, event); } break; case MAIN_ORDERED: if (mainThreadPoster != null) { mainThreadPoster.enqueue(subscription, event); } else { // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); } break; case BACKGROUND: if (isMainThread) { backgroundPoster.enqueue(subscription, event); } else { invokeSubscriber(subscription, event); } break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\u0026#34;Unknown thread mode: \u0026#34; + subscription.subscriberMethod.threadMode); } } post() 的总体流程图如下 :\nReferences :\nhttp://greenrobot.org/eventbus/ https://www.jianshu.com/p/f057c460c77e https://github.com/greenrobot/EventBus ","permalink":"https://chenyongda2018.github.io/posts/android/eventbus%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","summary":"\u003cp\u003eEventBus是一个消息订阅/发布的开源框架。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/15/16e6cfac7adeac21~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示 , EventBus框架中主要有2个角色 :\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePublisher : 发布消息的, 被观察者\u003c/li\u003e\n\u003cli\u003eSubscriber : 接收消息的 , 观察者\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ePublisher(被观察者)\u003c/code\u003e 通过 \u003ccode\u003epost()\u003c/code\u003e 将一个事件/消息(\u003ccode\u003eEvent\u003c/code\u003e) 发送到事件的集中地,也就是图中的 \u003ccode\u003eEventBus\u003c/code\u003e ，\u003ccode\u003eEventBus\u003c/code\u003e 再将事件/消息(\u003ccode\u003eEvent\u003c/code\u003e)发给\u003ccode\u003eSubcriber\u003c/code\u003e观察者。\u003c/p\u003e\n\u003cp\u003e使用这样的框架，能够使Activity/Fragment等组件之间的通信简化 , 不用再像以前一直使用 \u003ccode\u003eintent\u003c/code\u003e 来传送数据 , 从而提升开发效率。\u003c/p\u003e\n\u003ch2 id=\"1配置依赖\"\u003e1.配置依赖\u003c/h2\u003e\n\u003cp\u003e在app层的 \u003ccode\u003ebuild.gradle\u003c/code\u003e 中添加 :\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eimplementation\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"n\"\u003eorg\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003egreenrobot\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003eeventbus\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003e1\u003c/span\u003e\u003cspan class=\"err\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"2初步使用\"\u003e2.初步使用\u003c/h2\u003e\n\u003cp\u003e根据官方文档 , 首先要定义一个\u003ccode\u003eEvent(消息)\u003c/code\u003e的POJO类 :\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMessageEvent\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emessage\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eMessageEvent\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emessage\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003emessage\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emessage\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003egetMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emessage\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esetMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emessage\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003emessage\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emessage\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后 , 我们要明确哪个组件是 \u003ccode\u003eSubsriber(观察者)\u003c/code\u003e,  哪个组件是\u003ccode\u003ePublisher(被观察者)\u003c/code\u003e ,  在这里 , 我们通过EventBus演示一个传送消息的demo。\u003c/p\u003e","title":"EventBus使用详解及源码解析"},{"content":"ARGB A 是 alpha，透明度。 RGB 是 Red、Green、Blue，红色、绿色、蓝色，三种原色。\nBitmap.Config 有四种枚举类型。 ARGB_8888：ARGB 四个通道的值都是 8 位，加起来 32 位，也就是 4 个字节。每个像素点占用 4 个字节的大小。 ARGB_4444：ARGB 四个通道的值都是 4 位，加起来 16 位，也就是 2 个字节。每个像素点占用 2 个字节的大小。 RGB_565：RGB 三个通道分别是 5 位、6 位、5 位，没有 A 通道，加起来 16 位，也就是 2 个字节。每个像素点占用 2 个字节的大小。 ALPHA_8：只有 A 通道，占 8 位，1 个字节。每个像素点占用 1 个字节的大小。 那到底用哪个呢？ 很明显 ARGB_8888 的图片是质量最高的，但也是占用内存最大的。\n如果想要节省内存，可以使用 ARGB_4444 或者 RGB_565。它们相比 ARGB_8888 内存占用都小了一半。 ARGB_4444 图片的失真是比较严重的。 RGB_565 图片的失真虽然很小，但是没有透明度。\nALPHA_8 只有透明度，没有颜色值。对于在图片上设置遮盖的效果的是有很有用。\n总结一下！ ARGB_4444 图片失真严重，基本不用！ ALPHA_8 使用场景比较特殊！ 如果不设置透明度，RGB_565是个不错选择！ 既要设置透明度，对图片质量要求又高的化，那就用 ARGB_8888 !\n","permalink":"https://chenyongda2018.github.io/posts/android/android%E9%A2%9C%E8%89%B2%E6%A0%BC%E5%BC%8F%E5%8C%BA%E5%88%AB/","summary":"\u003ch3 id=\"argb\"\u003eARGB\u003c/h3\u003e\n\u003cp\u003eA 是 alpha，透明度。\nRGB 是 Red、Green、Blue，红色、绿色、蓝色，三种原色。\u003c/p\u003e\n\u003ch4 id=\"bitmapconfig-有四种枚举类型\"\u003eBitmap.Config 有四种枚举类型。\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eARGB_8888\u003c/strong\u003e：ARGB 四个通道的值都是 8 位，加起来 32 位，也就是 4 个字节。每个像素点占用 4 个字节的大小。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eARGB_4444\u003c/strong\u003e：ARGB 四个通道的值都是 4 位，加起来 16 位，也就是 2 个字节。每个像素点占用 2 个字节的大小。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRGB_565\u003c/strong\u003e：RGB 三个通道分别是 5 位、6 位、5 位，没有 A 通道，加起来 16 位，也就是 2 个字节。每个像素点占用 2 个字节的大小。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eALPHA_8\u003c/strong\u003e：只有 A 通道，占 8 位，1 个字节。每个像素点占用 1 个字节的大小。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"那到底用哪个呢\"\u003e那到底用哪个呢？\u003c/h4\u003e\n\u003cp\u003e很明显 ARGB_8888 的图片是质量最高的，但也是占用内存最大的。\u003c/p\u003e\n\u003cp\u003e如果想要节省内存，可以使用 ARGB_4444 或者 RGB_565。它们相比 ARGB_8888 内存占用都小了一半。\nARGB_4444 图片的失真是比较严重的。\nRGB_565 图片的失真虽然很小，但是没有透明度。\u003c/p\u003e\n\u003cp\u003eALPHA_8 只有透明度，没有颜色值。对于在图片上设置遮盖的效果的是有很有用。\u003c/p\u003e\n\u003cp\u003e总结一下！\nARGB_4444 图片失真严重，基本不用！\nALPHA_8 使用场景比较特殊！\n如果不设置透明度，RGB_565是个不错选择！\n既要设置透明度，对图片质量要求又高的化，那就用 ARGB_8888 !\u003c/p\u003e","title":"Android颜色格式区别"},{"content":"一.什么是内存泄漏 内存泄漏（英语：Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。 — — — 维基百科\n二.内存泄漏的影响 使得应用程序容易发生 OOM\nAndroid系统为每个应用分配的内存有限，若程序的发生的内存泄漏较多,会导致所需的内存超过系统所给的限额。 最终:OOM → Crash\n三. GC Roots 对于使用可达性分析的垃圾回收算法来说，GC roots是一个比较特别的存在，它用来帮助GC判断哪些对象可以被回收，如果这个对象被是GC roots 或者被GC roots引用就不会被回收。\n哪些可以作为GC roots?\nClass : 被系统ClassLoader加载的class,自定义的ClassLoader加载的class不是GC roots, 注意:静态变量是属于类的。 Thread: 处于活动状态的线程. Stack Local: 方法中的变量和参数. JNI Local: JNI方法中的变量和参数. JNI Global: 全局的JNI reference,也就是JNI中全局创建的引用. Monitor Used: 同步的对象,例如被 Synchronized 锁住的对象. Held by JVM: 取决于各个JVM的实现,系统的ClassLoader和JVM本身会用到的一些对象. 在开发中最常见的就是方法中的变量作为GC roots,如下代码:\n我们创建了80M大小的内存区域并用变量 b指向这块区域，然后我们调用gc。\n垃圾回收器首先进行了一次Minor GC，log中可以看到年轻代从3932K 降到了 560K，然后对象b转移到了老年代。\n随后垃圾回收器又进行了一次Full GC,老年代中的内存从81.9M 降到 439K, 也就是我们创建的80M内存被正常回收了。\n再看下面一段代码\n可以看到在Full GC时,分配的80M内存并没有被回收。\n原因: ByteArray对象被作为GC roots的变量b持有，无法被回收\n四.内存泄漏 in Android 内存泄漏的根本原因在于对象始终被GC roots引用，或者本身作为GC roots当不在使用时没有正确置空或释放。\n持有Activity的GC roots的引用链如下图\nActivity被置空的时机:\n在onDestory()方法执行时,ActivityThread通过handleDestroyActivity()方法将 Activity置空\n那么Activity被引用者置空后，对GC roots就不可达，可以正常被回收。\n1.Handler使用不规范 内部类/匿名内部类 隐式持有外部类的引用\nActivity → Handler → Message → MessageQueue → Looper()，有Looper()存在于整个应用的生命周期，所以，如果Activity销毁时，Handler发送的消息还未得到Looper()处理，将导致Activity泄漏\n内部类静态化 + WeakReference\n若垃圾收集器发现一个对象是弱可达的(weakly reachable)， 会清除所有指向该 对象的弱引用 通过static将内部类作为独立于外部类的Class 通过弱引用持有Activity,不耽误Activity回收 及时移除未处理的消息以及callback 消除message对Handler的引用\n2.匿名内部类 AsyncTask Thread 匿名接口回调 匿名内部类与内部类都会隐式持有外部类引用\n3.单例模式 单例模式的生命周期 = 整个app运行时,\n若需要引用context，请使用applicationContext\n4.注册的监听器未注销 EventBus class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) EventBus.getInstance().register(this) } } 在Activity销毁时需unregister(this)\nSensorManger void registerListener() { SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL); sensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_FASTEST); } View smButton = findViewById(R.id.sm_button); smButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { registerListener(); nextActivity(); } }); 在Activity销毁时需SensorManger.unregisterListener(this)\nContentObserver\ngetContentResolver().registerContentObserver( SOME_URI, true, yourObserver); getContentResolver().unregisterContentObserver(yourObserver); 5. 资源对象未及时关闭 file cursor bitmap \u0026hellip; 六.内存泄漏分析工具 Android Studio Monitor\nLeakCanary\n","permalink":"https://chenyongda2018.github.io/posts/android/android_memory_leak/","summary":"\u003ch2 id=\"一什么是内存泄漏\"\u003e一.什么是内存泄漏\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e内存泄漏\u003c/code\u003e（英语：Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。                                                                                                                 — — — 维基百科\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled\" loading=\"lazy\" src=\"https://tva1.sinaimg.cn/large/008i3skNly1gugdlcd1bij60i20b4wet02.jpg\"\u003e\u003c/p\u003e\n\u003ch2 id=\"二内存泄漏的影响\"\u003e二.内存泄漏的影响\u003c/h2\u003e\n\u003cp\u003e使得应用程序容易发生 \u003ccode\u003eOOM\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAndroid系统为每个应用分配的内存有限，若程序的发生的内存泄漏较多,会导致所需的内存超过系统所给的限额。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最终:OOM → Crash\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled 1\" loading=\"lazy\" src=\"https://tva1.sinaimg.cn/large/008i3skNly1guge4uumelj609l0gy0sy02.jpg\"\u003e\u003c/p\u003e\n\u003ch2 id=\"三-gc-roots\"\u003e三. GC Roots\u003c/h2\u003e\n\u003cp\u003e对于使用可达性分析的垃圾回收算法来说，GC roots是一个比较特别的存在，它用来帮助GC判断哪些对象可以被回收，如果这个对象被是GC roots 或者被GC roots引用就不会被回收。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled 2\" loading=\"lazy\" src=\"https://tva1.sinaimg.cn/large/008i3skNly1guge6kkyjoj61060j440402.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e哪些可以作为GC roots?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eClass :\u003c/strong\u003e 被系统ClassLoader加载的class,自定义的ClassLoader加载的class不是GC roots, 注意:静态变量是属于类的。\u003c/li\u003e\n\u003cli\u003eThread: 处于活动状态的线程.\u003c/li\u003e\n\u003cli\u003eStack Local: 方法中的变量和参数.\u003c/li\u003e\n\u003cli\u003eJNI Local: JNI方法中的变量和参数.\u003c/li\u003e\n\u003cli\u003eJNI Global: 全局的JNI reference,也就是JNI中全局创建的引用.\u003c/li\u003e\n\u003cli\u003eMonitor Used: 同步的对象,例如被 \u003ccode\u003eSynchronized\u003c/code\u003e  锁住的对象.\u003c/li\u003e\n\u003cli\u003eHeld by JVM: 取决于各个JVM的实现,系统的ClassLoader和JVM本身会用到的一些对象.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在开发中最常见的就是方法中的变量作为GC roots,如下代码:\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Untitled 3\" loading=\"lazy\" src=\"https://tva1.sinaimg.cn/large/008i3skNly1guge6uh97bj60w809smyg02.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e我们创建了80M大小的内存区域并用变量 b指向这块区域，然后我们调用gc。\u003c/p\u003e\n\u003cp\u003e垃圾回收器首先进行了一次Minor GC，log中可以看到年轻代从3932K 降到了 560K，然后对象b转移到了老年代。\u003c/p\u003e\n\u003cp\u003e随后垃圾回收器又进行了一次Full GC,老年代中的内存从81.9M 降到 439K, 也就是我们创建的80M内存被正常回收了。\u003c/p\u003e","title":"Android内存泄漏探究"},{"content":"1.布局优化 深入探索Android布局优化（上） 深入探索Android布局优化（中） 深入探索Android布局优化（下） 2.绘制优化 Android性能优化之绘制优化 3.卡顿优化 深入探索Android卡顿优化（上） 深入探索Android卡顿优化（下） 4.内存优化 深入探索 Android 内存优化（炼狱级别-上） 深入探索 Android 内存优化（炼狱级别-下） 5.启动速度优化 深入探索Android启动速度优化（上） 深入探索Android启动速度优化（下） 6.包体积优化 深入探索 Android 包体积优化（匠心制作-上） 深入探索 Android 包体积优化（匠心制作-下） 包体积优化 · 工具论 · 初识包体积优化 包体积优化 · 方法论 · 揭开包体积优化神秘面纱 包体积优化 · 实战论 · 怎么做包体积优化? 包体积优化 · 彩蛋篇 · Android编译期PNG自动化转换WEBP 7.APM APM监控 · 入门篇 · Android端测监控平台建设 卡顿监测 · 方案篇 · Android卡顿监测指导原则 ","permalink":"https://chenyongda2018.github.io/posts/android/android_performance/","summary":"\u003ch2 id=\"1布局优化\"\u003e1.布局优化\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904047355363341\"\u003e深入探索Android布局优化（上）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6870445845834104846\"\u003e深入探索Android布局优化（中）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904048068395015\"\u003e深入探索Android布局优化（下）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2绘制优化\"\u003e2.绘制优化\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904080989487118#heading-47\"\u003eAndroid性能优化之绘制优化\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"3卡顿优化\"\u003e3.卡顿优化\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904062610046990\"\u003e深入探索Android卡顿优化（上）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904066259091469\"\u003e深入探索Android卡顿优化（下）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"4内存优化\"\u003e4.内存优化\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904099998089230\"\u003e深入探索 Android 内存优化（炼狱级别-上）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6872919545728729095\"\u003e深入探索 Android 内存优化（炼狱级别-下）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"5启动速度优化\"\u003e5.启动速度优化\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904093786308622\"\u003e深入探索Android启动速度优化（上）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904093786308622\"\u003e深入探索Android启动速度优化（下）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"6包体积优化\"\u003e6.包体积优化\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7176622003888226362#heading-33\"\u003e深入探索 Android 包体积优化（匠心制作-上）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6872920643797680136\"\u003e深入探索 Android 包体积优化（匠心制作-下）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7176622003888226362#heading-33\"\u003e包体积优化 · 工具论 · 初识包体积优化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7177195746272215098\"\u003e包体积优化 · 方法论 · 揭开包体积优化神秘面纱\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7179230851853451323\"\u003e包体积优化 · 实战论 · 怎么做包体积优化?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6897894068068876295\"\u003e包体积优化 · 彩蛋篇 · Android编译期PNG自动化转换WEBP\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"7apm\"\u003e7.APM\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904163600498701\"\u003eAPM监控 · 入门篇 · Android端测监控平台建设\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7214635327407308859\"\u003e卡顿监测 · 方案篇 · Android卡顿监测指导原则\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"Android性能优化文章"},{"content":"Kotlin lambda Kotlin中，充斥着各种各样的Lambda 表达式，这是Kotlin最方便的特性之一\n了解Kotlin 中的lambda，首先得知道Kotlin中的高阶函数\n1.高阶函数 在Java中，如果有一个a方法，要去调用b方法，那么在里面直接调用即可。\nint a() { return b(1); } a(); 接着,如果我不想把调用b方法的参数写死，希望动态设置方法b的参数。\nint a(int param) { return b(param); } a(1); a(2); 这些在Java中很轻松就能做到，不过\u0026hellip; 如果我们想动态设置的不是方法参数，而是方法本身呢，比如在方法a内有一处对别的方法的调用，这个方法可能是方法b,方法c,方法d\u0026hellip;,该方法的参数类型是int,返回值类型也是int。方法a在执行时，具体需要调用哪个方法，能否动态设置? 也就是说能否将一个方法作为参数传给a?\n通过接口\npublic interface Wrapper { int method(int param); } 将这个接口类型Wrapper 作为方法a的参数\nint a(Wrapper wrapper) { return wrapper.method(1); } a(wrapper1); a(wrapper2); 举个我们常见的例子\n在Android里View的点击事件\npublic class View { OnClickListener mOnClickListener; ... public void onTouchEvent(MotionEvent e) { ... mOnClickListener.onClick(this); ... } } OnClickListener就是一个接口，点击事件的内容全在onClick()方法里\npublic interface OnClickListener { void onClick(View v); } 我们在给View设置点击事件时，传的就是一个OnClickListener,本质上这样传递的是一个稍后会被调用的onClick()方法,一般称之为回调,不过由于Java中不允许直接传递方法，所以需要用接口包装一下。\nOnClickListener listener1 = new OnClickListener() { @Override void onClick(View v) { doSomething(); } }; view.setOnClickListener(listener1); 在Kotlin里，函数是可以作为一个参数被传递的 :\nfun setOnClickListener(onClick: (View) -\u0026gt; Unit) { this.onClick = onClick } 👇传入一个匿名方法，参数类型时View,无返回值 view.setOnClickListener(fun(v: View): Unit) { doSomething() }) 这种 参数或者返回值是函数的函数 在Kotlin中称之为高阶函数(Higher-Order-Functions)\n2. Lambda表达式 在刚刚的代码中，传入的匿名函数还能进一步简化，写成Lambda表达式的形式\n👇简化后的匿名方法 view.setOnClickListener( { v: View -\u0026gt; doSomething() } ) Kotlin允许如果Lambda 是最后一个参数时，Lambda可以写在方法()的外面：\nview.setOnClickListener() { v: View -\u0026gt; doSomething() } 如果该Lambda 是唯一的参数，则方法()可以省略\nview.setOnClickListener { v: View -\u0026gt; doSomething() } 进一步，如果该Lambda 只有一个参数，该参数还可以省略不写, Kotlin为这种唯一参数提供了默认的名字it\nview.setOnClickListener { doSomething() it.visibility = GONE } 3. 为什么Kotlin中函数可以作为参数被传递? 将刚才的代码，反编译为Java:\n👇实际传递的是FunctionN类型的对象 public static final String a(@NotNull Function1 funParam) { Intrinsics.checkNotNullParameter(funParam, \u0026#34;funParam\u0026#34;); return (String)funParam.invoke(1); } interface FunctionN\u0026lt;out R\u0026gt; : Function\u0026lt;R\u0026gt;, FunctionBase\u0026lt;R\u0026gt; { operator fun invoke(vararg args: Any?): R override val arity: Int } 所以，之所以Kotlin中方法可以被当作参数 进行传递，是因为它实际一个FunctionN类型的实实在在的对象\n对应关系:\n表达式 FunctionN (String) -\u0026gt; Unit Function1\u0026lt;String,Int\u0026gt; (String,Int) -\u0026gt; Double Function2\u0026lt;String,Int,Double\u0026gt; \u0026hellip; \u0026hellip; (参数1类型,参数2类型..参数n类型) -\u0026gt; 返回值类型 FunctionN\u0026lt;参数1类型,\u0026hellip;,参数n类型,返回值类型\u0026gt; 4.inline内联函数 集合操作符 filter 可以定义规则对集合进行过滤\nlistOf(1,2,3,4,5,6).filter {it \u0026gt; 2} 看一下 filter 方法的声明\npublic inline fun \u0026lt;T\u0026gt; Iterable\u0026lt;T\u0026gt;.filter(predicate: (T) -\u0026gt; Boolean): List\u0026lt;T\u0026gt; { return filterTo(ArrayList\u0026lt;T\u0026gt;(), predicate) } public inline fun \u0026lt;T, C : MutableCollection\u0026lt;in T\u0026gt;\u0026gt; Iterable\u0026lt;T\u0026gt;.filterTo(destination: C, predicate: (T) -\u0026gt; Boolean): C { for (element in this) if (predicate(element)) destination.add(element) return destination } filter方法接收一个 函数类型的参数，并且返回值是boolean，符合使用lambda的场景，上面我们说过，lamdba是实现了FunctionN接口的对象。 如果集合里有成百上千个元素，那每次经过filter 都会生成匿名对象，是一个不容忽视的开销,引起性能问题。 所以,Kotlin中引入了内联函数的概念:\n内联函数回把函数的实现直接拷贝的调用处,避免创建匿名内部类。\ninline fun inlined(getString: () -\u0026gt; String) = println(getString()) fun notInlined(getString: () -\u0026gt; String) = println(getString()) fun test() { var testVar = \u0026#34;Test\u0026#34; notInlined { testVar } inlined { testVar } } 编译后的java代码:\npublic static final void test() { final ObjectRef testVar = new ObjectRef(); testVar.element = \u0026#34;Test Variable\u0026#34;; // notInlined: //每个闭包 lamdba 都是一个对象会额外分配内存，影响运行时间 notInlined((Function0)(new Function0(0) { public Object invoke() { return this.invoke(); } @NotNull public final String invoke() { return (String)testVar.element; } })); // inlined:会直接将方法体复制到调用处， String var3 = (String)testVar.element; System.out.println(var3); } 在 kotlin 中，因为出现了大量的带 lamdba的 高阶函数 \u0026ndash; 「高阶函数是将函数用作参数或返回值的函数」，使得越来越多的地方出现 函数参数 不断传递的现象，每一个函数参数都会被编译成一个对象， 使得内存分配（对于函数对象和类）和虚拟调用会增加运行时间开销，通过内联化 lambda 表达式可以消除这类的开销。\n","permalink":"https://chenyongda2018.github.io/posts/android/kotlin_lamdba/","summary":"\u003ch1 id=\"kotlin-lambda\"\u003eKotlin lambda\u003c/h1\u003e\n\u003cp\u003eKotlin中，充斥着各种各样的\u003ccode\u003eLambda\u003c/code\u003e 表达式，这是Kotlin最方便的特性之一\u003c/p\u003e\n\u003cp\u003e了解Kotlin 中的\u003ccode\u003elambda\u003c/code\u003e，首先得知道Kotlin中的\u003ccode\u003e高阶函数\u003c/code\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"1高阶函数\"\u003e1.高阶函数\u003c/h2\u003e\n\u003cp\u003e在Java中，如果有一个a方法，要去调用b方法，那么在里面直接调用即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e接着,如果我不想把调用b方法的参数写死，希望动态设置方法b的参数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eparam\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eparam\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这些在Java中很轻松就能做到，不过\u0026hellip;\n如果我们想动态设置的不是方法参数，而是方法本身呢，比如在方法a内有一处对别的方法的调用，这个方法可能是方法b,方法c,方法d\u0026hellip;,该方法的参数类型是int,返回值类型也是int。方法a在执行时，具体需要调用哪个方法，能否动态设置? 也就是说能否将一个方法作为参数传给a?\u003c/p\u003e\n\u003cp\u003e通过接口\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003einterface\u003c/span\u003e \u003cspan class=\"nc\"\u003eWrapper\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003emethod\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eparam\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e将这个接口类型\u003ccode\u003eWrapper\u003c/code\u003e 作为方法a的参数\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eWrapper\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ewrapper\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ewrapper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003emethod\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ewrapper1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ewrapper2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e举个我们常见的例子\u003c/p\u003e\n\u003cp\u003e在Android里View的点击事件\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eView\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"n\"\u003eOnClickListener\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emOnClickListener\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e...\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eonTouchEvent\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eMotionEvent\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e...\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"n\"\u003emOnClickListener\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eonClick\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e...\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eOnClickListener\u003c/code\u003e就是一个接口，点击事件的内容全在\u003ccode\u003eonClick()\u003c/code\u003e方法里\u003c/p\u003e","title":"Kotlin Lambda"},{"content":" Java体系中的自动内存管理主要包括了2个方面:\n自动地给对象分配内存。 自动地回收分配给对象地内存。 本文也围绕这两个点展开 一. 内存分配规则 1.优先在Eden区分配 大多数情况下，JVM会在 Eden 区优先分配对象，如果 Eden 没有足够的空间，则进行一次 Minor GC 。通过参数 -XX:+PrintGCDetails 可以让虚拟机在进行垃圾回收时打印日志，方便我们看到回收前后的内存占用情况。\n例: 假如现在内存大小指定如下:\n新生代 -\u0026gt;10M Eden区 -\u0026gt; 8M from区 -\u0026gt; 1M to 区 -\u0026gt; 1M 老年代 -\u0026gt; 10M 然后我们又先后在代码中创建4个对象:\nbyte[] byte1 = new byte[2MB]; byte[] byte2 = new byte[2MB]; byte[] byte3 = new byte[2MB]; byte[] byte4 = new byte[4MB]; 当创建完第三个对象后，Eden区已经用掉了6M的空间来存放 byte1,byte2,byte3 三个对象，再创建第四个对象时,Eden区加上一个from区已经放不下了，如先前所述，此时会触发一次 MinorGC ,将三个2MB的对象转移到老年代中，腾出Eden区的空间给 第四个对象。\n所以，执行后的内存情况如下:\n新生代 -\u0026gt; 10M Eden 区 -\u0026gt; 8M (剩余4M) 存放 byte4 from区 -\u0026gt; 1M to区 -\u0026gt; 1M 老年代 -\u0026gt; 10M (剩余4M) 存放byte1,byte2,byte3。 2.大对象直接进入老年代 通过 -XX:PretentureSizeThreshold 参数设置大于这个值的对象直接分配到老年代。\n3.长期存活的对象进入老年代 怎么算是长期存活 ?\nJVM给每个对象定义了一个 对象年龄计数器 。当对象一开始被分配到新生代Eden区，经过一次 MniorGC 后仍然存活，并且Survivor区能够容纳它，则此对象被转移到 Survivor 区，年龄变为1。在 Survivor 区中的对象没熬过一次 MniorGC ,年龄就涨1，当年龄达到我们设定的年龄阈值(JVM默认设定15)时，就会进入老年代。15岁就已经步入老年\u0026hellip;.年龄阈值可通过参数 -XX:MaxTenuringThreshold = 指定值 来设定。\n对对象年龄判定的优化 JVM中，如果Survivor区中的相同年龄的所有对象的大小总和大于Survivor空间的一半，那么这些同窗们就直接进入老年代。无须等到上面的年龄阈值。 二. 空间分配担保机制与回收策略(Mnior GC还是Full GC) 首先介绍一下 Mnior GC 和 Full GC 的区别:\nMniorGC : 发生在新生代的垃圾回收活动，由于新生代的Java对象 短命的特性，这种垃圾回收活动频繁，回收速度较快。(就像扫碎纸屑) Full GC : 发生在老年的垃圾回收活动，不过出现一次 Full GC,也会伴随着一次 MniorGC,由于老年代中的对象基本都是大对象，长命，所以Full GC的速度比Mnior GC 的速度慢10倍以上。(就像搬大石头)\n新生代的垃圾回收算法采用的是 复制算法 ,当进行一次 Mnior GC 时，会将新生代的活动区域( Eden区 和Survivor中的 From区 )中的存活对象复制到 Survivor中的 to区 ,如果 to 区的内存不足以放下这些对象，那么这时就需要老年代出马，进行分配担保机制,将放不下的对象放到老年代。 所以，在进行 Monior GC 前，JVM会做以下流程的检查，以确认老年代是否能够放得下那些对象，来选择进行 Mnior GC 还是 Full GC 。\nReference:深入理解Java虚拟机 ","permalink":"https://chenyongda2018.github.io/posts/java/jvm%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E9%80%89%E6%8B%A9-jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","summary":"\u003cblockquote\u003e\n\u003cp\u003eJava体系中的自动内存管理主要包括了2个方面:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e自动地给对象分配内存。\u003c/li\u003e\n\u003cli\u003e自动地回收分配给对象地内存。\u003c/li\u003e\n\u003c/ol\u003e\u003c/blockquote\u003e\n\u003cp\u003e本文也围绕这两个点展开\n\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch2 id=\"一-内存分配规则\"\u003e一. 内存分配规则\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/24/16b8975973c1114c~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch3 id=\"1优先在eden区分配\"\u003e1.优先在Eden区分配\u003c/h3\u003e\n\u003cp\u003e大多数情况下，JVM会在 \u003ccode\u003eEden\u003c/code\u003e 区优先分配对象，如果 \u003ccode\u003eEden\u003c/code\u003e 没有足够的空间，则进行一次 \u003ccode\u003eMinor GC\u003c/code\u003e 。通过参数 \u003ccode\u003e-XX:+PrintGCDetails\u003c/code\u003e 可以让虚拟机在进行垃圾回收时打印日志，方便我们看到回收前后的内存占用情况。\u003c/p\u003e\n\u003cp\u003e例: 假如现在内存大小指定如下:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e新生代 -\u0026gt;10M\n\u003cul\u003e\n\u003cli\u003eEden区 -\u0026gt; 8M\u003c/li\u003e\n\u003cli\u003efrom区 -\u0026gt; 1M\u003c/li\u003e\n\u003cli\u003eto 区 -\u0026gt; 1M\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e老年代 -\u0026gt; 10M\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e然后我们又先后在代码中创建4个对象:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003ebyte\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ebyte1\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003ebyte\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e2MB\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003ebyte\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ebyte2\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003ebyte\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e2MB\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003ebyte\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ebyte3\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003ebyte\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e2MB\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003ebyte\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ebyte4\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003ebyte\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e4MB\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当创建完第三个对象后，Eden区已经用掉了6M的空间来存放 byte1,byte2,byte3 三个对象，再创建第四个对象时,Eden区加上一个from区已经放不下了，如先前所述，此时会触发一次 \u003ccode\u003eMinorGC\u003c/code\u003e ,将三个2MB的对象转移到老年代中，腾出Eden区的空间给 第四个对象。\u003c/p\u003e","title":"JVM内存分配机制与回收策略选择 JVM学习笔记[2]"},{"content":"\n本章要探究的问题 : GC在回收内存时 :\n怎么判断哪些内存需要回收 ？ 什么时候回收？ 在几个线程私有的运行时区域:\n虚拟机栈 程序计数器 本地方法栈 它们的内存分配和回收大多都具有确定性，随着线程的创建而产生，随着线程的停止而被回收。栈帧中的内存大小基本在类的结构确定下来时就已知。\n而在线程共有的 Java堆(Heap) 和 方法区(Class(Method) Area) 这两个区域则不同：\n比如，一个接口有不同的实现类(类的信息在方法区中)，这几个实现类的内存大小肯定不一，没法在运行前就已知需要多大的内存，只有在运行期间才知道创建的对象的大小。\n一，哪些内存需要回收？ 在知道哪些内存需要回收之前，我们要知道怎么判断一个对象是否还存活，当它不再存活时，就回收它。而 引用计数算法 就是用来判断对象是否存活的一个算法。\n1，引用计数算法（Reference Counting） 算法描述：给对象添加一个引用计数器，当有一个地方引用了它，计数器+1，当引用失效，计数器-1，在任何时刻，计数器为0时此对象将不能再被使用。\n引用计数法在大多数情况下表现都不错，也有被很多公司采用的应用案例。但是在JVM中并没有采用这种算法，原因是：无法解决对象之间存在相互引用的问题。\npublic class Person { Object instance = null; public static void main(String[] args) { Person a = new Person(); Person b = new Person(); a.instance = b; b.instance = a; a = null; b = null;// 正常情况下在这里GC就会把a,b回收掉 } } 正常情况下在执行11-12行代码时，JVM的GC会把a,b两个对象回收，但是在引用计数算法的情况下：\n执行 a=null 时,a的引用计数器值为1，因为b对象在引用它。 执行 b=null 时,b的引用计数器值为1，因为a对象在引用它。 2，可达性分析(Reachability Analysis)算法 在Java语言中是通过可达性分析来判断对象是否存活。 算法描述 : 通过一系列的 GC Roots 作为起始点，从这些起始点开始向下搜索，能搜索的到的对象说明其可用，不会被GC回收掉，搜索所走过的路径称为 引用链(Reference Chain) 。相反，如果一个对象没有到达GC Roots的路径，则说明它不可用，被判定为可被GC回收的对象。\n如图 : 1区域的对象虽然互相关联，但是它们不可到达GC Roots,所以他们会被回收掉，而2区域的对象与GC Roots之间是有可到达路径的，所以它们不会被回收。\n什么是GC Roots ? 虚拟机栈(栈帧中的本地变量表)中引用的对象 方法区中类的静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI(Native方法)引用的对象 这些都可作为GC Roots.\n3，什么是引用（Reference） 我们在上面的 引用计数算法 和 可达性分析 中，都提到了 对象之间的引用 关系。\n在Java1.2之前,关于 引用 的定义 :\n如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就说这块内存代表一个引用。\nJDK1,2之后,又引入了 强引用 ， 软引用 ， 弱引用 ， 虚引用 ,这四个概念，并且这四种表现的引用关系越来越弱。\n强引用(Strong Reference) : 例:\nObject o = new Object(); 只要强引用还在，GC永远不会回收掉被引用的对象。\n软引用(Soft Reference) : 有用，但非必须，在将要发生内存溢出时，会把 软引用 的对象回收掉，如果内存依然不够用，则抛出OOM异常。\n弱引用(Weak Reference): 非必需对象，只要GC发生了垃圾回收，不管此时内存是否充足， 弱引用 的对象都会被回收掉。\n虚引用(Phantom Reference): 最弱的引用关系 无法通过虚引用构造市实例。 唯一的作用就是在虚引用关联的对象被GC回收掉时，可以接受到一个信号。 4，如何判断一个对象可回收(已死)？ 一个对象仅仅通过上面说的可达性分析看它没有与GC ROOTS关联来判定这个对象是否可被回收是不够的。\n一个对象要经过下面一段判断过程来判断它是否要被回收(建议收藏(^__^) 嘻嘻……):\n5，方法区的回收 上面我们说的是存在于Java堆中的对象的回收，但其实在方法区还要回收以下东西：\n① 回收废弃常量 假如常量池中有一个字符串 \u0026ldquo;abc\u0026rdquo; ,但是系统中没有一个String 对象指向它，也就是这个常量没有被引用，当GC在回收时会回收此字面量。\n② 回收废弃的类(无用的类) 该类的实例都已被回收，Java堆中不存在任何该类的实例。 加载该类的ClassLoader已经被回收。 该类的Java.lang.class对象没有被引用(在反射中会被用到这点)。 ③ 方法区的回收策略: GC在回收方法区时会采用一下2种方式:\n标记-整理 标记-清除 二，如何回收？ GC在回收内存时会采用多种垃圾收集算法，这些算法各有优劣。\n1.标记-清除(Mark-Sweep)算法 此算法是最基础也是最古老的垃圾回收算法，该算法主要经过2个过程 ① 算法描述 标记阶段:经过如何判断一个对象可被回收所述，对可被回收的对象进行标记。 清除阶段:将被标记的对象统一回收。 ② 算法缺陷 效率问题:此种算法标记和清除的效率都不高。 标记清除后产生大量不连续的内存空间碎片。 2.复制(Copying)算法 复制算法针对效率问题进行了优化，它将内存区域划分为2块，每次只使用其中一块。\n活动区域 空闲区域 ① 算法描述 如图:\n回收前 : 内存被划分为左右两侧区域，右侧为空闲区域，暂时不使用它 回收时 : 将左侧要被回收的部分(黑色) 回收掉，然后将4个存活对象(淡灰色)移动到右侧的空闲区域，并且做了2件事 将移动到空闲区域的存活对象按内存地址进行排列。 将存活对象指向的旧地址指向新内存地址。 回收后 : 原先的右侧空闲区域变为活动区域，左侧的活动区域变为空闲区域。 左右两侧的区域状态在每一次回收后都来回转换\u0026hellip;\n② 算法缺陷 很显然，这种算法浪费了一般内存。 当活动区域的100%的对象都还在活跃，那么在回收时需要将全部的对象复制到右侧的空闲区域，此时的效率就很低。 ③ 算法应用 IBM公司经研究表明，Java堆新生代种的对象98%是 \u0026lsquo;朝生夕死\u0026rsquo; 的对象，比如临时变量等作用域很少的对象。所以现在的虚拟机并不会按照 1:1的比例划分两个区域。\n现在的JVM虚拟机中，将新生代划分为一块 Eden 区域，和2块较小的 Survivor 区域(from ,to区)。每次使用Eden区和1块Survivor区(from区)最为活动区域，当发生内存回收时，将这2块内存中的存活对象复制到另一块Survivor区(to区)。\n在 HotSpot 虚拟机中，Eden区和Survivor的划分是: 8: 1，这样，活动区域占新生代的 (8+1)/10 *100% = 90%，只有10%的内存浪费。\n老年代 : 当将存活对象从活动区域(Eden,from) 复制到 to区时，如果to区不够用，则将剩下的存活对象放到老年代。 3.标记-整理算法 标记-整理主要运用于老年代中。\n① 算法描述 此算法与标记-清除算法类似，也是经历2个阶段:\n标记阶段:此阶段于标记-清除中的标记阶段相同，都是标记出要回收的对象。 整理阶段:把所有存活的对像，按内存地址排列移动到内存区域的一端，将端边界以外的区域进行回收。 ② 算法应用 由于老年代的特点，对象的存活率较高，没有额外的空闲区域，所以 老年代适用 标记-清除和标记-整理算法。\nReference:深入理解Java虚拟机\n","permalink":"https://chenyongda2018.github.io/posts/java/%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E5%88%A4%E5%AE%9A%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95-jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","summary":"\u003cp\u003e\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch1 id=\"本章要探究的问题-\"\u003e本章要探究的问题 :\u003c/h1\u003e\n\u003cp\u003eGC在回收内存时 :\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e怎么判断哪些内存需要回收 ？\u003c/li\u003e\n\u003cli\u003e什么时候回收？\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在几个线程私有的运行时区域:\u003c!-- raw HTML omitted --\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/17/16b64d8a41ca08fb~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e虚拟机栈\u003c/li\u003e\n\u003cli\u003e程序计数器\u003c/li\u003e\n\u003cli\u003e本地方法栈\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e它们的内存分配和回收\u003cstrong\u003e大多\u003c/strong\u003e都具有确定性，随着线程的创建而产生，随着线程的停止而被回收。栈帧中的内存大小基本在类的结构确定下来时就已知。\u003c/p\u003e\n\u003cp\u003e而在线程共有的 \u003ccode\u003eJava堆(Heap)\u003c/code\u003e 和 \u003ccode\u003e方法区(Class(Method) Area)\u003c/code\u003e 这两个区域则不同：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/17/16b64d8a42c57ecf~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e比如，一个接口有不同的实现类(类的信息在方法区中)，这几个实现类的内存大小肯定不一，没法在运行前就已知需要多大的内存，只有在运行期间才知道创建的对象的大小。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch2\u003e\u003c/h2\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch2 id=\"一哪些内存需要回收\"\u003e一，哪些内存需要回收？\u003c/h2\u003e\n\u003cp\u003e在知道哪些内存需要回收之前，我们要知道怎么判断一个对象是否还存活，当它不再存活时，就回收它。\u003c!-- raw HTML omitted --\u003e而 \u003ccode\u003e引用计数算法\u003c/code\u003e 就是用来判断对象是否存活的一个算法。\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch3 id=\"1引用计数算法reference-counting\"\u003e1，引用计数算法（Reference Counting）\u003c/h3\u003e\n\u003cp\u003e算法描述：给对象添加一个引用计数器，当有一个地方引用了它，计数器+1，当引用失效，计数器-1，在任何时刻，计数器为0时此对象将不能再被使用。\u003c/p\u003e","title":"对象回收判定与垃圾回收算法 JVM学习笔记[1]"},{"content":"一.使用 1.配置依赖 在 app 层 build.gradle 中添加依赖 : dependencies { ... implementation \u0026#39;com.github.bumptech.glide:glide:4.9.0\u0026#39; annotationProcessor \u0026#39;com.github.bumptech.glide:compiler:4.9.0\u0026#39; annotationProcessor \u0026#39;androidx.annotation:annotation:1.1.0\u0026#39; ... } 添加必要权限 : \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34; /\u0026gt; 2.初步上手 代码 : Glide.with(context) .asBitmap() //把动图当作静止图片处理,也就是只显示gif图的第一帧 .load(\u0026#34;https://pic2.zhimg.com/v2-c4970ee756c55333b7b871c5b617d9ed_b.gif\u0026#34;)//图片url .placeholder(R.mipmap.ic_launcher) //占位符,在加载图片完成之前显示的图片 .error(R.drawable.ic_launcher_background) //加载失败时显示的图片 .fitCenter() //当图片长宽大于ImageView时,缩放图片 .fallback(R.mipmap.ic_launcher) //图片url为Null时显示的图片 .into(image1); // 放入到ImageView中 效果图 :\n🎈Tips : fitCenter()与CenterCrop()区别 : fitCenter() : 效果如上图,缩放原图至ImageView大小。 CenterCrop():如下图,保持原图不变，只根据ImageView大小显示对应部分。 3.配合RecyclerView显示图片列表 1.需要加载的图片url数据源\nString[] mImageList = { \u0026#34;https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D0%2C231%2C438%\u0026#34; + \u0026#34;2C219%3BeWH%3D800%2C400/sign=b9c61bb42b3fb80e189e3b970be1031c/d50735fae6cd7b89267e2d06052442a7d9330e20.jpg\u0026#34;, \u0026#34;https://s3.ifanr.com/wp-content/uploads/2018/02/https_2F2Fhk.hypebeast.com2Ffiles2F20182F012Fdragon-ball-super-ending-anime-details-01-1.jpg\u0026#34;, \u0026#34;https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=999dccfe8082b90139adc431438ca97e/a1ec08fa513d26970f8fef845ffbb2fb4216d88f.jpg\u0026#34;, \u0026#34;http://img5.mtime.cn/CMS/News/2019/05/28/223631.52706895_620X620.jpg\u0026#34;, \u0026#34;http://newsimg.5054399.com/uploads/userup/1902/2F95FQ953.jpg\u0026#34;, \u0026#34;http://x0.ifengimg.com/cmpp/2019_37/63ef72f4f79be26_size61_w1278_h716.jpg\u0026#34;, \u0026#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQJehCL30Zj-jAI8xxZ1eQI6mf9DuqaC6LXEOzF-Li8-Y1YlSnJ\u0026amp;s\u0026#34;, \u0026#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRTzaN89LyHy1IzuibIhUdvJjEiCdrn8R84BnUi4O6hlPtmJZWe\u0026amp;s\u0026#34;, \u0026#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQGFNu4QL1YIazFeV-hVtIv686UNFqJwjReiObeCmAZiFvl7CHJ\u0026amp;s\u0026#34;, \u0026#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQyMlTlY90LK_A_nbv8egC6yZkhvd4WmAHOoMzwVuGaH8VJKQga\u0026amp;s\u0026#34;, \u0026#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSNfpqnbeGqjIObnVpLipvUve0QGjT3PANsVoAEsKSvvmFdozMD\u0026amp;s\u0026#34;, \u0026#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTjTT47tCkv6wy93-JIno1Egv-0QQQ5rvKmSTZ9gZ5Jd64VPY2o\u0026amp;s\u0026#34;, \u0026#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQGFNu4QL1YIazFeV-hVtIv686UNFqJwjReiObeCmAZiFvl7CHJ\u0026amp;s\u0026#34;, }; 2.item的布局\n\u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/imageView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:layout_margin=\u0026#34;10dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; tools:srcCompat=\u0026#34;@tools:sample/avatars\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 3.adapter\npublic class ImageListAdapter extends RecyclerView.Adapter\u0026lt;ImageListAdapter.ViewHolder\u0026gt; { private Context mContext; private String[] mImageList; private LayoutInflater mInflater; RequestOptions mOptions = new RequestOptions() .placeholder(R.mipmap.ic_launcher) .error(R.drawable.ic_launcher_background); public ImageListAdapter(Context mContext, String[] mImageList) { this.mContext = mContext; this.mImageList = mImageList; mInflater = LayoutInflater.from(mContext); } public class ViewHolder extends RecyclerView.ViewHolder { public ImageView imageView; public ViewHolder(@NonNull View itemView) { super(itemView); imageView = (ImageView) itemView.findViewById(R.id.imageView); } } @NonNull @Override public ImageListAdapter.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view = mInflater.inflate(R.layout.main_activity_list_item,parent,false); return new ViewHolder(view); } @Override public void onBindViewHolder(@NonNull ImageListAdapter.ViewHolder holder, int position) { Glide.with(mContext) .load(mImageList[position]) .apply(mOptions) .into(holder.imageView); } @Override public int getItemCount() { return mImageList.length; } } 在activity中绑定Recyclerview和数据源 RecyclerView.LayoutManager linearLayoutManager = new LinearLayoutManager(getApplicationContext()); ImageListAdapter adapter = new ImageListAdapter(this,mImageList); mRecyclerView = findViewById(R.id.recyclerView); mRecyclerView.setLayoutManager(linearLayoutManager); mRecyclerView.setAdapter(adapter); 效果图:\n5.缓存 内存缓存 : 通过 skipMemoryCache(true)可以设置不进行内存缓存 磁盘缓存 : diskCacheStrategy(DiskCacheStrategy) 参数中有四个选项 : DiskCacheStrategy.ALL : 既缓存原图也缓存处理图\nDiskCacheStrategy.NONE : 啥都不缓存 = 禁用磁盘缓存\nDiskCacheStrategy.SOURCE : 只缓存原图\nDiskCacheStrategy.RESULT : 只缓存处理图\nBitmapPool : 避免反复创建同样尺寸的bitmap而维护的一个bitmap池.\n🎈Tips :Glide的读取缓存顺序是 : 先从内存中读取缓存,若没有再从磁盘中读取,若没有再从load中加载。\n设置Glide只从缓存中加载图片，否则加载失败。 Glide.with(fragment) .load(url) .onlyRetrieveFromCache(true) .into(imageView); 清理内存缓存 Glide.get(context).clearMemory(); //需要在主线程运行 清理磁盘缓存(需要在子线程运行) new AsyncTask\u0026lt;Void, Void, Void\u0026gt; { @Override protected Void doInBackground(Void... params) { Glide.get(applicationContext).clearDiskCache(); return null; } } Glide对资源的重用机制 Glide通过 引用计数法 来判断一个资源是否正在被使用 :\n当一个资源通过 into() 方法加载时,它的 引用计数 就会+1 当承载资源A的 View 或者 Target 调用了 clear() 或者又调用了 into() 加载了别的资源时, A资源的 引用计数 -1。 当一个资源的 计数为0时，就会被释放，Glide可以重用该资源。\n6.使用缩略图(Thumbnail) 1.当你已经有图片的缩略图的资源时,可以直接用url/uri加载\nGlideApp.with(mContext) .asDrawable() .load(原图url) .thumbnail(Glide.with(mContext) .load(缩略图url)) .into(holder.imageView); 2.没有缩略图的资源时，也可以直接传入想要缩小的倍数\nGlide.with(mContext) .asDrawable() .load(mImageList[position]) .thumbnail(0.1f) //缩略图大小为原来的 1/10 .into(holder.imageView); 7.Target Target对象用来保存每一个Glide请求。如:\nTarget\u0026lt;Drawable\u0026gt; target = Glide.with(mContext) .asDrawable() .load(R.drawable.ic_launcher_foreground) .into(holder.imageView); 这样做的目的是可以有效的对glide请求进行管理，取消请求，清理资源。\n清理之前的请求 : Target\u0026lt;Drawable\u0026gt; target = Glide.with(mContext) .asDrawable() .load(R.drawable.ic_launcher_foreground) .into(holder.imageView); Glide.with(fragment).clear(target); //清理之前的加载,节省资源 当使用这个target再发出新的加载请求时,glide也会对上一次的加载进行清理，释放资源。\nTarget\u0026lt;Drawable\u0026gt; target = Glide.with(mContext) .asDrawable() .load(R.drawable.ic_launcher_foreground) .into(holder.imageView); Glide.with(mContext) .load(mImageList[position]) .fitCenter() .into(target); 8.过渡动画(Transitions) 根据官方文档描述 , 过渡动画只能作用于一个请求中的(不能作用于先后2个不同的请求) : 从占位符-\u0026gt;原图的过程 从缩略图-\u0026gt;原图的过程 示例: 可以发现占位图到原图之间的渐变效果 Glide.with(mContext) .load(mImageList[position]) .transition(withCrossFade(600)) //设置渐变的持续时长600ms .placeholder(R.drawable.ic_launcher_foreground) .centerCrop() .into(holder.imageView); 9.自定义Module 通过自定义module可以方便我们根据项目的实际需求来定制化glide。\n首先新建一个类继承 AppGlideModule ,并用 @GlideModule 注解: /** * 通过继承AppGlideModule来自定义Glide * @author chenyongda */ @GlideModule public class MyGlideApp extends AppGlideModule { } 再重新 ReBuild 一下项目 ,将代码中之前的 Glide.with() 换成 GlideApp.with() : GlideApp.with(mContext) .load(mImageList[position]) .placeholder(R.mipmap.ic_launcher) .error(R.drawable.ic_launcher_background) .into(holder.imageView); 在applyIOptions()中进行自定义配置: 比如,我们想让glide默认情况下不进行任何缓存。\n@Override public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) { //不缓存图片 RequestOptions options = new RequestOptions() //不进行内存缓存 .skipMemoryCache(true) //不进行磁盘缓存 .diskCacheStrategy(DiskCacheStrategy.NONE); builder.setDefaultRequestOptions(options); //设置为默认配置 } 在 applyOptions() 函数中还可以对缓存根据需要进行自定义\n自定义内存缓存：\n最大缓存20m的图片\n@Override public void applyOptions(Context context, GlideBuilder builder) { int memoryCacheSizeBytes = 1024 * 1024 * 20; // 20mb builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes)); } 二.源码解析 1.Glide.with() : Glide的生命周期管理 进入Glide.with()方法 :\n@NonNull public static RequestManager with(@NonNull Context context) { return getRetriever(context).get(context); } 首先看一下 getRetriever() 方法:\n@NonNull private static RequestManagerRetriever getRetriever(@Nullable Context context) { // Context could be null for other reasons (ie the user passes in null), but in practice it will // only occur due to errors with the Fragment lifecycle. Preconditions.checkNotNull( context, \u0026#34;You cannot start a load on a not yet attached View or a Fragment where getActivity() \u0026#34; + \u0026#34;returns null (which usually occurs when getActivity() is called before the Fragment \u0026#34; + \u0026#34;is attached or after the Fragment is destroyed).\u0026#34;); return Glide.get(context).getRequestManagerRetriever(); } 通过注释了解到 :这个方法先对context进行判空,也就是当view还没加载时或者fragment还没与activity建立联系时。\n看一下 Glide.get(context) 方法 : /** * Get the singleton. * * @return the singleton */ @NonNull public static Glide get(@NonNull Context context) { if (glide == null) { synchronized (Glide.class) { if (glide == null) { checkAndInitializeGlide(context); } } } return glide; } 这是一个DCL双重检验锁的单例模式 。\ncheckAndInitializeGlide() 方法 : private static void checkAndInitializeGlide(@NonNull Context context) { // In the thread running initGlide(), one or more classes may call Glide.get(context). // Without this check, those calls could trigger infinite recursion. if (isInitializing) { throw new IllegalStateException(\u0026#34;You cannot call Glide.get() in registerComponents(),\u0026#34; + \u0026#34; use the provided Glide instance instead\u0026#34;); } isInitializing = true; initializeGlide(context); isInitializing = false; } 这个方法用来保证glide在同一时刻只能有一个线程在初始化它。\nRequestManagerRetriever : 这个类是 Glide 的一个辅助类，用来创建一个新的 RequestManager 对象或者获得一个已存在的 acitivity/fragment , 那 RequestManager将请求与activity/fragment等组件建立联系。\n再看一下 RequestMangerRetriever类的get()方法 : @NonNull public RequestManager get(@NonNull Context context) { if (context == null) { throw new IllegalArgumentException(\u0026#34;You cannot start a load on a null Context\u0026#34;); } else if (Util.isOnMainThread() \u0026amp;\u0026amp; !(context instanceof Application)) { if (context instanceof FragmentActivity) { return get((FragmentActivity) context); } else if (context instanceof Activity) { return get((Activity) context); } else if (context instanceof ContextWrapper) { return get(((ContextWrapper) context).getBaseContext()); } } return getApplicationManager(context); } 这个方法通过将我们传入的 context ，转换为与 application/activity/fragment建立联系的 ReuqestManger 类 ,加入我们传入的是 activity,点进第 9 行代码 :\n@NonNull public RequestManager get(@NonNull Activity activity) { if (Util.isOnBackgroundThread()) { //当我们在子线程用glide,glide会把请求与整个app的生命周期建立联系. return get(activity.getApplicationContext()); } else { assertNotDestroyed(activity); //用于创建fragment android.app.FragmentManager fm = activity.getFragmentManager(); return fragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); } } 点进第8行的 fragmentGet() :\nprivate RequestManager fragmentGet(@NonNull Context context, @NonNull android.app.FragmentManager fm, @Nullable android.app.Fragment parentHint, boolean isParentVisible) { //创建一个隐藏的Fragment RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible); RequestManager requestManager = current.getRequestManager(); //如果获得的RequestManager为空的话就创建一个。 if (requestManager == null) { Glide glide = Glide.get(context); requestManager = factory.build( glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context); //把RequestManager赋给Fragment current.setRequestManager(requestManager); } return requestManager; } 到这里可以发现 Glide与activity建立联系的关键在于:\n创建了一个无UI的Fragment 创建了一个 RequestManager ,并通过 current.getGlideLifecycle() 将fragment的 ActivityFragmentLifecycle 成员传给了 RequestManager 。 无UI的Fragment通过 setRequestManager() 与 RequestManager 建立联系。 第12行代码中创建 RequestManager 对象时 调用了 RequestManager 的构造方法 : 构造方法的22行调用了ActivityFragmentLifecycle 的 addListener()方法将 RequestManager 添加到自己的监听器列表中。\nRequestManager( Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode, RequestTracker requestTracker, ConnectivityMonitorFactory factory, Context context) { this.glide = glide; this.lifecycle = lifecycle; this.treeNode = treeNode; this.requestTracker = requestTracker; this.context = context; connectivityMonitor = factory.build( context.getApplicationContext(), new RequestManagerConnectivityListener(requestTracker)); if (Util.isOnBackgroundThread()) { mainHandler.post(addSelfToLifecycle); } else { //将 RequestManager 添加到自己的监听器列表中。 lifecycle.addListener(this); } lifecycle.addListener(connectivityMonitor); defaultRequestListeners = new CopyOnWriteArrayList\u0026lt;\u0026gt;(glide.getGlideContext().getDefaultRequestListeners()); setRequestOptions(glide.getGlideContext().getDefaultRequestOptions()); glide.registerRequestManager(this); } 为了看清楚Glide是如何与组件activity/fragment建立生命周期联系，我们先从刚刚的无UI的Fragment-\u0026gt; RequestManagerFragment 这个类的生命周期看起 :\npublic class RequestManagerFragment extends Fragment { private static final String TAG = \u0026#34;SupportRMFragment\u0026#34;; private final ActivityFragmentLifecycle lifecycle; @Override public void onStart() { super.onStart(); lifecycle.onStart(); } @Override public void onStop() { super.onStop(); lifecycle.onStop(); } @Override public void onDestroy() { super.onDestroy(); lifecycle.onDestroy(); unregisterFragmentWithRoot(); } } 这个fragment中的生命周期方法中,又调用了对应的 ActivityFragmentLifecycle 的方法 : class ActivityFragmentLifecycle implements Lifecycle { private final Set\u0026lt;LifecycleListener\u0026gt; lifecycleListeners = Collections.newSetFromMap(new WeakHashMap\u0026lt;LifecycleListener, Boolean\u0026gt;()); private boolean isStarted; private boolean isDestroyed @Override public void addListener(@NonNull LifecycleListener listener) { lifecycleListeners.add(listener); if (isDestroyed) { listener.onDestroy(); } else if (isStarted) { listener.onStart(); } else { listener.onStop(); } } @Override public void removeListener(@NonNull LifecycleListener listener) { lifecycleListeners.remove(listener); } void onStart() { isStarted = true; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) { lifecycleListener.onStart(); } } void onStop() { isStarted = false; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) { lifecycleListener.onStop(); } } void onDestroy() { isDestroyed = true; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) { lifecycleListener.onDestroy(); } } } ActivityFragmentLifecycle 中有一个 Set\u0026lt;LifecycleListener\u0026gt; 类型的集合,而 RequestManager 也正好实现了 LifecycleListener 这个接口 ,看一下 RequestManager 中的 onStart() 方法 : @Override public synchronized void onStart() { //处理请求 resumeRequests(); targetTracker.onStart(); } @Override public synchronized void onStop() { pauseRequests(); targetTracker.onStop(); } public synchronized void resumeRequests() { requestTracker.resumeRequests(); } ... 所以现在可以看出,Glide与组件的生命周期相关联的方法是基于类似链式的结构。\nActivity的生命周期会引起无UI的Fragment的生命周期变化. Fragment的生命周期会会调用自己成员变量 ActivityFragmentLifecycle 中对应的onXXX()方法. ActivityFragmentLifecycle 的onXXX()方法内部又调用了 RequestManager 的方法。 2.load(url) : 在load()这一环节需要我们传入需要加载的图片的链接.\n@Override public RequestBuilder\u0026lt;Drawable\u0026gt; load(@Nullable String string) { return asDrawable().load(string); } load方法默认调用了 asDrawable() 方法 : 方法主要作用是创建一个加载 Drawable 资源类型的 RequestBuilder 。\npublic RequestBuilder\u0026lt;Drawable\u0026gt; asDrawable() { return as(Drawable.class); } public \u0026lt;ResourceType\u0026gt; RequestBuilder\u0026lt;ResourceType\u0026gt; as( @NonNull Class\u0026lt;ResourceType\u0026gt; resourceClass) { return new RequestBuilder\u0026lt;\u0026gt;(glide, this, resourceClass, context); } 查看一下 load() 方法 : 将String字符串赋予model变量\npublic RequestBuilder\u0026lt;TranscodeType\u0026gt; load(@Nullable String string) { return loadGeneric(string); } private RequestBuilder\u0026lt;TranscodeType\u0026gt; loadGeneric(@Nullable Object model) { this.model = model; isModelSet = true;//这个变量表示已经调用过load(),在into()中会再次用到此变量。 return this; } 而这个model变量将在后面的 into() 中使用。\n3.into() public ViewTarget\u0026lt;ImageView, TranscodeType\u0026gt; into(@NonNull ImageView view) { //判断当前是否是在主线程,因为这里涉及到改变UI Util.assertMainThread(); //检查ImageView是否为空 Preconditions.checkNotNull(view); BaseRequestOptions\u0026lt;?\u0026gt; requestOptions = this; if (!requestOptions.isTransformationSet() \u0026amp;\u0026amp; requestOptions.isTransformationAllowed() \u0026amp;\u0026amp; view.getScaleType() != null) { // Clone in this method so that if we use this RequestBuilder to load into a View and then // into a different target, we don\u0026#39;t retain the transformation applied based on the previous // View\u0026#39;s scale type. switch (view.getScaleType()) { case CENTER_CROP: requestOptions = requestOptions.clone().optionalCenterCrop(); break; case CENTER_INSIDE: requestOptions = requestOptions.clone().optionalCenterInside(); break; case FIT_CENTER: case FIT_START: case FIT_END: requestOptions = requestOptions.clone().optionalFitCenter(); break; case FIT_XY: requestOptions = requestOptions.clone().optionalCenterInside(); break; case CENTER: case MATRIX: default: // Do nothing. } } return into( //由ImageView构建出Target glideContext.buildImageViewTarget(view, transcodeClass), /*targetListener=*/ null, requestOptions, Executors.mainThreadExecutor()); } 这里的into()方法只是根据ImageView的比例类型，对 RequestOptions 进行配置。\n36行的into()方法中用 GlideContext 的 buildImageViewTarget() 用 ImageView 构建出 Target.\n看一下这个方法 :\n@NonNull public \u0026lt;X\u0026gt; ViewTarget\u0026lt;ImageView, X\u0026gt; buildImageViewTarget( @NonNull ImageView imageView, @NonNull Class\u0026lt;X\u0026gt; transcodeClass) { return imageViewTargetFactory.buildTarget(imageView, transcodeClass); } public class ImageViewTargetFactory { @NonNull @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public \u0026lt;Z\u0026gt; ViewTarget\u0026lt;ImageView, Z\u0026gt; buildTarget(@NonNull ImageView view, @NonNull Class\u0026lt;Z\u0026gt; clazz) { if (Bitmap.class.equals(clazz)) { //Bitmap类型的ViewTarget return (ViewTarget\u0026lt;ImageView, Z\u0026gt;) new BitmapImageViewTarget(view); } else if (Drawable.class.isAssignableFrom(clazz)) { //Drawable类型的ViewTarget return (ViewTarget\u0026lt;ImageView, Z\u0026gt;) new DrawableImageViewTarget(view); } else { throw new IllegalArgumentException( \u0026#34;Unhandled class: \u0026#34; + clazz + \u0026#34;, try .as*(Class).transcode(ResourceTranscoder)\u0026#34;); } } } 可以看出 ImageViewTargetFactory 这个类就是用来把 ImageView 转化为2种(Bitmap,Drawable) 类型的 ViewTarget的。\n而我们之前在分析 load() 方法时看到默认情况下把资源当作 Drawable 类型处理 , 所以一般情况下都是生成的 DrawableImageViewTarget 。\n@Override public RequestBuilder\u0026lt;Drawable\u0026gt; load(@Nullable String string) { return asDrawable().load(string); } 继续深入之前的 into() 方法。\nprivate \u0026lt;Y extends Target\u0026lt;TranscodeType\u0026gt;\u0026gt; Y into( @NonNull Y target, //把创建的Target传进来 @Nullable RequestListener\u0026lt;TranscodeType\u0026gt; targetListener, BaseRequestOptions\u0026lt;?\u0026gt; options, Executor callbackExecutor) { //Target不能为空 Preconditions.checkNotNull(target); // isModelSet在load()被调用过才会为true if (!isModelSet) { throw new IllegalArgumentException(\u0026#34;You must call #load() before calling #into()\u0026#34;); } //创建Request对象 , 稍后解析 Request request = buildRequest(target, targetListener, options, callbackExecutor); //获取此ImageView的之前的请求对象 Request previous = target.getRequest(); //如果此次的请求和之前的请求相同并且启用了内存缓存 if (request.isEquivalentTo(previous) \u0026amp;\u0026amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) { //回收请求资源 request.recycle(); //若上一次的请求没有在加载，则再执行这个请求 if (!Preconditions.checkNotNull(previous).isRunning()) { previous.begin(); } return target; } //若这次请求与上次不同,则取消上一次请求 requestManager.clear(target); target.setRequest(request); requestManager.track(target, request); return target; } ","permalink":"https://chenyongda2018.github.io/posts/android/glide_study/","summary":"\u003ch1 id=\"一使用\"\u003e一.使用\u003c/h1\u003e\n\u003ch2 id=\"1配置依赖\"\u003e1.配置依赖\u003c/h2\u003e\n\u003cp\u003e在 \u003ccode\u003eapp\u003c/code\u003e 层 \u003ccode\u003ebuild.gradle\u003c/code\u003e 中添加依赖 : \u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edependencies {\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    implementation \u0026#39;com.github.bumptech.glide:glide:4.9.0\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    annotationProcessor \u0026#39;com.github.bumptech.glide:compiler:4.9.0\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    annotationProcessor \u0026#39;androidx.annotation:annotation:1.1.0\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e添加必要权限 : \u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;uses-permission\u003c/span\u003e \u003cspan class=\"na\"\u003eandroid:name=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;android.permission.INTERNET\u0026#34;\u003c/span\u003e\u003cspan class=\"nt\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;uses-permission\u003c/span\u003e \u003cspan class=\"na\"\u003eandroid:name=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34;\u003c/span\u003e\u003cspan class=\"nt\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;uses-permission\u003c/span\u003e \u003cspan class=\"na\"\u003eandroid:name=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34;\u003c/span\u003e \u003cspan class=\"nt\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;uses-permission\u003c/span\u003e \u003cspan class=\"na\"\u003eandroid:name=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34;\u003c/span\u003e \u003cspan class=\"nt\"\u003e/\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"2初步上手\"\u003e2.初步上手\u003c/h2\u003e\n\u003cp\u003e代码 : \u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eGlide\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ewith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003easBitmap\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e//把动图当作静止图片处理,也就是只显示gif图的第一帧\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eload\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;https://pic2.zhimg.com/v2-c4970ee756c55333b7b871c5b617d9ed_b.gif\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"c1\"\u003e//图片url\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eplaceholder\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eR\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003emipmap\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eic_launcher\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//占位符,在加载图片完成之前显示的图片\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eR\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003edrawable\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eic_launcher_background\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e//加载失败时显示的图片\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003efitCenter\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e//当图片长宽大于ImageView时,缩放图片\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003efallback\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eR\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003emipmap\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eic_launcher\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e//图片url为Null时显示的图片\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003einto\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eimage1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 放入到ImageView中\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e效果图 :\u003c/p\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e🎈Tips : fitCenter()与CenterCrop()区别 : \u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efitCenter() : 效果如上图,缩放原图至ImageView大小。\u003c/li\u003e\n\u003cli\u003eCenterCrop():如下图,保持原图不变，只根据ImageView大小显示对应部分。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003ch2 id=\"3配合recyclerview显示图片列表\"\u003e3.配合RecyclerView显示图片列表\u003c/h2\u003e\n\u003cp\u003e1.需要加载的图片url数据源\u003c/p\u003e","title":"Glide学习笔记"},{"content":"前言 最近实验室开了个新项目，是一个通过扫描单词后把扫描过的单词生成游戏来让小朋友记单词的APP，扫描单词这个功能需要用到OCR.\n现在常用的OCR有\nTesseract 这个用的人比较多，而且开源，目前google正在维护，但是我尝试了一下，发现识别准确率不是特别理想。\n微软的Azure上的认知服务 识别率很高，但是收费，现在有1元体验的套餐，而且不需要验证信用卡，感兴趣的同学可以试试。\n百度的文字识别 之所以用这个是因为免费，不过有每天的限制次数，对于学生项目来说够用，还要什么自行车。\n下面进入正文\n如何在Android 中调用百度的OCR进行文字识别 1.获取百度文字识别产品服务的 Ak/Sk 1.在百度AI开放平台中进入控制台\n2.找到文字识别 产品服务\n3,创建应用\n4,填写信息，注意这里的包名一定要和项目的包名一致\n5.获得AK/SK\n6.下载license文件，在项目中如果直接用AK/SK明文调用百度的OCR，很不安全，可能会被别人反编译之后获得你的AK.SK\nlicense文件集成了AK/SK 放在项目中可以防止别人破解。 7.下载之后将获得的api.license文件放入main目录下的assets目录中\n2.添加百度OCR的SDK到项目中 1.下载 百度OCR的android Sdk\n2.下载的SDK压缩包将其解压，并将libs下的ocr-sdk的jar包放入项目的libs目录下 3.在main目录下新建jniLibs目录，并将libs文件夹中的其他文件放入其中\n4.在app下的build,gradle中添加\n将添加在libs下的sdk JAR包编译\n5.这里下载的压缩包中包括了百度提供的相机扫描时的UI，在拍完照有裁剪框，比较方便，这里我们可以作为module引入项目中 3.调用百度OCR 做完准备工作我们就可以开始调用百度的OCR接口了。\n首先在我们需要进行识别的页面所在的文件中创建 根据License文件初始化OCR实例的函数，并在onCreate()方法中调用\n/** * 自定义license的文件路径和文件名称，以license文件方式初始化 */ private void initAccessTokenLicenseFile() { OCR.getInstance(mActivity.getApplicationContext()).initAccessToken(new OnResultListener\u0026lt;AccessToken\u0026gt;() { @Override public void onResult(AccessToken accessToken) { String token = accessToken.getAccessToken(); Log.d(TAG,token); hasGotToken = true; } @Override public void onError(OCRError error) { error.printStackTrace(); alertText(\u0026#34;自定义文件路径licence方式获取token失败\u0026#34;, error.getMessage()); } }, \u0026#34;aip.license\u0026#34;, mActivity.getApplicationContext()); } 定义我们的打开相机事件\n/** * 打开相机，进入的相机页面是借用百度OCR 官方DEMO中的相机页面 * 能够在相机中裁剪图片，和进入图库 * @author cyd */ private void openCameraForResult() { if (!checkTokenStatus()) { return; } Intent intent = new Intent(mActivity, CameraActivity.class); intent.putExtra(CameraActivity.KEY_OUTPUT_FILE_PATH, FileUtil.getSaveFile(getActivity()).getAbsolutePath()); intent.putExtra(CameraActivity.KEY_CONTENT_TYPE, CameraActivity.CONTENT_TYPE_GENERAL); startActivityForResult(intent, REQUEST_CODE_GENERAL_BASIC); } 这里的CameraActivity用的是引入OCR_UI中的相机活动，自带剪裁框\n接下来需要我们新建一个可以存放OCR的识别方法的类RecognizeService\n** * 这个类是用于将拍摄或者图库中获得的图片进行识别，返回JSON格式的字符串。 */ public class RecognizeService { public interface ServiceListener { public void onResult(String result); } //高精度版 public static void recAccurateBasic(Context ctx, String filePath, final ServiceListener listener) { GeneralParams param = new GeneralParams(); param.setDetectDirection(true); param.setVertexesLocation(true); param.setLanguageType(GeneralBasicParams.ENGLISH); param.setRecognizeGranularity(GeneralParams.GRANULARITY_SMALL); param.setImageFile(new File(filePath)); //这里的recognizeAccurateBasic方法为百度OCR识别的核心方法 OCR.getInstance(ctx).recognizeAccurateBasic(param, new OnResultListener\u0026lt;GeneralResult\u0026gt;() { @Override public void onResult(GeneralResult result) { StringBuilder sb = new StringBuilder(); for (WordSimple wordSimple : result.getWordList()) { WordSimple word = wordSimple; sb.append(word.getWords()); sb.append(\u0026#34;\\n\u0026#34;); } listener.onResult(result.getJsonRes()); } @Override public void onError(OCRError error) { listener.onResult(error.getMessage()); } }); } } 在onActivityResult方法中，我们调用刚刚新建的类的recAccurateBasic方法，此方法接收三个参数，分别是context,拍照获取的图片路径，和在RecognizeService类中定义的监听接口，这里的获取图片路径方法，我用的是百度官方DEMO中的方法\n在onResult方法中，返回的result字符串即为识别结果的json字符串，只需要对JSON解析一下就能得到识别结果啦\n@Override public void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode) { case REQUEST_CODE_GENERAL_BASIC: if (resultCode == Activity.RESULT_OK) { RecognizeService.recAccurateBasic(mActivity, FileUtil.getSaveFile(mActivity.getApplicationContext()).getAbsolutePath(), new RecognizeService.ServiceListener() { @Override public void onResult(String result) { Bundle bundle = new Bundle(); bundle.putString(\u0026#34;wordResultJson\u0026#34;,result ); Intent intent = new Intent(mActivity,SelectWordsActivity.class); intent.putExtra(\u0026#34;wordResultBundle\u0026#34;,bundle ); startActivity(intent); } }); } break; default: Log.d(TAG, \u0026#34;onActivityResult: \u0026#34;+\u0026#34;run in default\u0026#34;); break; } } FileUtil类\npublic class FileUtil { public static File getSaveFile(Context context) { File file = new File(context.getFilesDir(), \u0026#34;pic.jpg\u0026#34;); return file; } } (完~)\n","permalink":"https://chenyongda2018.github.io/posts/android/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8android%E4%B8%AD%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E7%9A%84ocr%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%8F%E5%8E%86/","summary":"\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003e最近实验室开了个新项目，是一个通过扫描单词后把扫描过的单词生成游戏来让小朋友记单词的APP，扫描单词这个功能需要用到OCR.\u003cbr\u003e\n现在常用的OCR有\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/tesseract-ocr/tesseract\"\u003eTesseract\u003c/a\u003e 这个用的人比较多，而且开源，目前google正在维护，但是我尝试了一下，发现识别准确率不是特别理想。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e微软的Azure上的\u003ca href=\"https://www.azure.cn/zh-cn/home/features/cognitive-services/computer-vision/\"\u003e认知服务\u003c/a\u003e 识别率很高，但是收费，现在有1元体验的套餐，而且不需要验证信用卡，感兴趣的同学可以试试。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e百度的\u003ca href=\"https://cloud.baidu.com/doc/OCR/OCR-API.html#.E8.AF.B7.E6.B1.82.E8.AF.B4.E6.98.8E\"\u003e文字识别\u003c/a\u003e 之所以用这个是因为免费，不过有每天的限制次数，对于学生项目来说够用，还要什么自行车。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e下面进入正文\u003c/p\u003e\n\u003ch1 id=\"如何在android-中调用百度的ocr进行文字识别\"\u003e如何在Android 中调用百度的OCR进行文字识别\u003c/h1\u003e\n\u003ch2 id=\"1获取百度文字识别产品服务的-aksk\"\u003e1.获取百度文字识别产品服务的 Ak/Sk\u003c/h2\u003e\n\u003cp\u003e1.在\u003ca href=\"http://ai.baidu.com/tech/ocr\"\u003e百度AI开放平台\u003c/a\u003e中进入控制台\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c3207893f26~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e2.找到文字识别 产品服务\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c33733f10e6~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e3,创建应用\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c3205d91865~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e4,填写信息，\u003cstrong\u003e注意这里的包名一定要和项目的包名一致\u003c/strong\u003e\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c32077c3cb0~tplv-t2oaga2asx-image.image\"\u003e\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c3208e59688~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e5.获得AK/SK\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c320ae4cfd7~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e6.下载license文件，在项目中如果直接用AK/SK明文调用百度的OCR，很不安全，可能会被别人反编译之后获得你的AK.SK\u003cbr\u003e\nlicense文件集成了AK/SK 放在项目中可以防止别人破解。\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c32bfbe0ac0~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e7.下载之后将获得的api.license文件放入main目录下的assets目录中\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c32321a5ee2~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003ch2 id=\"2添加百度ocr的sdk到项目中\"\u003e2.添加百度OCR的SDK到项目中\u003c/h2\u003e\n\u003cp\u003e1.下载 \u003ca href=\"https://ai.baidu.com/sdk#ocr\"\u003e百度OCR的android Sdk\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c33207fef3d~tplv-t2oaga2asx-image.image\"\u003e\u003cbr\u003e\n2.下载的SDK压缩包将其解压，并将libs下的ocr-sdk的jar包放入项目的libs目录下 \u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c332114fc9f~tplv-t2oaga2asx-image.image\"\u003e\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c3327d5bc7b~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e3.在main目录下新建jniLibs目录，并将libs文件夹中的其他文件放入其中\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c33330971ce~tplv-t2oaga2asx-image.image\"\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c333ab33813~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cp\u003e4.在app下的build,gradle中添加\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c339602cd1c~tplv-t2oaga2asx-image.image\"\u003e\u003cbr\u003e\n将添加在libs下的sdk JAR包编译\u003c/p\u003e\n\u003cp\u003e5.这里下载的压缩包中包括了百度提供的相机扫描时的UI，在拍完照有裁剪框，比较方便，这里我们可以作为module引入项目中\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c33a2e8f5e2~tplv-t2oaga2asx-image.image\"\u003e\u003cbr\u003e\n\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c339b46cc37~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003ch2 id=\"3调用百度ocr\"\u003e3.调用百度OCR\u003c/h2\u003e\n\u003cp\u003e做完准备工作我们就可以开始调用百度的OCR接口了。\u003c/p\u003e\n\u003cp\u003e首先在我们需要进行识别的页面所在的文件中创建 根据License文件初始化OCR实例的函数，并在onCreate()方法中调用\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e/**\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e     * 自定义license的文件路径和文件名称，以license文件方式初始化\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e     */\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003einitAccessTokenLicenseFile\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eOCR\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003egetInstance\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emActivity\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003egetApplicationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e()).\u003c/span\u003e\u003cspan class=\"na\"\u003einitAccessToken\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eOnResultListener\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eAccessToken\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eonResult\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eAccessToken\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eaccessToken\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etoken\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eaccessToken\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003egetAccessToken\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"n\"\u003eLog\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ed\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTAG\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003etoken\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"n\"\u003ehasGotToken\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"nd\"\u003e@Override\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eonError\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOCRError\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"n\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eprintStackTrace\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"n\"\u003ealertText\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;自定义文件路径licence方式获取token失败\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003egetMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e},\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;aip.license\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003emActivity\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003egetApplicationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/10/16aa0c33cd0b0b3a~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e","title":"记一次在Android中调用百度的OCR接口的经历"},{"content":"(1),Android消息机制概述 Android中的消息机制主要指 Handler的运行机制 以及 MessageQueue，Looper的工作过程 ，三者相互协作，保证着消息的接收，发送，处理，执行。\n​ 图片来自郭神的《第一行代码》\n先简单的介绍一下 Android 中 消息机制大家庭的主要成员 :\nHandler : 是Android消息机制的上层接口，最为大家常用，相当于Android消息机制的入口，我们通过使用Handler发送消息来引起消息机制的循环。通常用于:在子线程执行完耗时任务完后，更新UI。\nMessageQueue : 存储 消息(Message) 对象的消息队列，实则是单链表结构.\nLooper : 用于无限的从 MessageQueue中取出消息，相当于消息的永动机，如果有新的消息，则处理执行，若没有，则就一直等待，堵塞。Looper** 所在的线程是 创建 Handler 时所在的线程。\n主线程创建Handler时，会自动创建一个Looper,但是子线程并不会自动创建Looper\nThreadLocal : 在每个线程互不干扰的存储，提供数据，以此来获取当前线程的Looper\nActivityThread : Android 的主线程，也叫UI线程，主线程被创建时 自动初始化主线程的 Looper对象。\n问题 : 大家都知道只有在UI线程才能对UI元素进行操作，在子线程更改UI就会报错，为什么？ 看完《Android艺术开发探索》 这本书的第10章之后我也才明白\nAndroid中的UI控件不是线程安全的，如果在子线程中也能修改UI元素，那多线程的时，共同访问同一个UI元素，就会导致这个UI元素处于我们不可预知的状态，这个线程让它往左一点，那个线程让它往右一点，UI该听谁的，好tm乱。。 干脆我就只听主线程的把。 问题 : 那为什么不通过对访问UI控件的子线程加上锁机制呢 ？ 这个很简单了，如果为不同的线程访问同一UI元素加上锁机制，那我们程序员写相关代码的时候会变得超级麻烦。。。 改个UI还得考虑它是不是已经被别的线程占用了，被占用了，还得让那个线程释放锁。。。线程再多一点的话，大大地加大了程序员地工作量.\n而且加上锁机制无疑会由于线程堵塞地原因降低访问UI的效率，帧率降低，体验也会不友好。\n让UI元素只能再主线程访问就会省下很多事，创建一个Handler就行了。\n下面从整体概述一下 消息机制的整个工作过程 :\nHandler 创建时会采用当前线程的 Looper来构建内部的消息循环系统，如果Handler在子线程，则一开始是没有Looper对象的(解决方法稍后介绍)，主线程ActivityThread默认有一个Looper。\nHandler创建完毕，通过 post方法传入Runnable对象，或者通过sendMessage(Message msg)发送消息。\npost()方法里也是通过调用send()实现的\nsend()方法被调用后，调用 MessageQueue的enqueueMessage()方法将消息发送到消息队列中，等待被处理。\nLooper对象运行在Handler所在的线程，从MessageQueue消息队列中不断地取出消息，处理，所以业务逻辑(通常是更新UI)就运行在Looper的线程中。\n接下来从局部来分析消息机制的每个成员。\n(2),ThreadLocal 工作原理 1, 什么是ThreadLocal？ ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中获得存储数据，获得数据，线程之间的ThreadLocal相互独立，且无法获得另一个线程的TheadLocal.\n相对整个程序来说，每个线程的ThreadLocal是局部变量。\n相对一个线程来说，线程内的ThreadLocal是线程的全局变量\nThreadLocal是一个泛型类，可以存储任意类型的对象。\n示例:\npublic class ThreadLocalTest { public static void main(String[] args) { ThreadLocal\u0026lt;Boolean\u0026gt; mThreadLocal = new ThreadLocal\u0026lt;Boolean\u0026gt;(); mThreadLocal.set(true); System.out.println(\u0026#34;#Main Thread : ThreadLocal \u0026#34; + mThreadLocal.get()); new Thread( new Runnable() { @Override public void run() { mThreadLocal.set(false); System.out.println(\u0026#34;#1 Thread : ThreadLocal \u0026#34; + mThreadLocal.get()); } }).start(); new Thread( new Runnable() { @Override public void run() { System.out.println(\u0026#34;#2 Thread : ThreadLocal \u0026#34; + mThreadLocal.get()); } }).start(); } } 我们在主线程创建一个 泛型为Boolean的ThreadLocal，并.set(True),然后在第一个子线程中.set(False)，在第二个子线程中不做修改，直接打印。 可以看到，在不同的线程中获得的值也不同。\n输出 :\n#Main Thread : ThreadLocal true #1 Thread : ThreadLocal false #2 Thread : ThreadLocal null 2，ThreadLocal的实现原理 首先每个线程内部都维护着一个ThreadLocalMap对象\nThread.Java\n/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; 这个ThraedLocalMap 与Map类似，一个线程内可以有多个ThreadLocal类型变量，所以通过ThreadLocalMap \u0026lt;ThreadLocal\u0026lt;?\u0026gt; key, Object value\u0026gt;.保存着多个\u0026lt;ThreadLocal , 任意类型对象\u0026gt;键值对。\n看一下ThreadLocal的set()方法实现 :\n/** * Sets the current thread\u0026#39;s copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the {@link #initialValue} * method to set the values of thread-locals. * * @param value the value to be stored in the current thread\u0026#39;s copy of * this thread-local. */ public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } 先是获得当前线程的ThreadLocalMap对象，map.set(this,value) 设置了我这个ThreadLocal存储的值.\nget()方法实现 :\n/** * Returns the value in the current thread\u0026#39;s copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the {@link #initialValue} method. * * @return the current thread\u0026#39;s value of this thread-local */ public T get() { Thread t = Thread.currentThread();//获得当前线程 ThreadLocalMap map = getMap(t);//根据根据获得它的ThreadLocalMap if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this);//获得\u0026lt;k,v\u0026gt;键值对 if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T result = (T)e.value;//通过\u0026lt;k,v\u0026gt;获得值 return result; } } return setInitialValue(); } 3，ThreadLocal的使用场景 一般，当某些数据是以线程为作用域，并且不同的线程具有不同的数据副本时，可以考虑用ThreadLocal\n场景1: 对于Handler,它想要获得当前线程的Looper，并且Looper的作用域就是当前的线程，不同的线程具有不同的Looper对象，这时可以使用ThreadLocal。\n场景2: 复杂逻辑下的对象的传递，如果想要一个对象贯穿着整个线程的执行过程，可采用Threadlocal让此对象作为该线程的全局对象。\n(3),MessageQueue的工作原理 以单链表的形式，存储着Handler发送过来的消息，再来一张图加深印象\n主要包含两个操作:\n通过enqueueMessage(Message msg,long when)，像队列插入一个消息,这里为了节省篇幅，就不上源码，贴上源码连接,MessageQueue.enqueueMessage() 通过next()从无限循环队列中取出消息，并从消息队列中删除。MessageQueue.next() 虽然它叫做消息队列，但内部其实是以单链表的结构存储，有利于插入，删除的操作。\n(4),Looper的工作原理 它的主要作用就是 不停地从消息队列中 查看是否有新的消息，如果有新的消息就会立刻处理，没有消息就会堵塞。\n持有MessageQueue的引用，并且会在构造方法中初始化\nprivate Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 问题: 如何在子线程创建它的Looper对象 ? 前面说到主线程自己会创建一个Looper对象，所以我们在主线程使用Handler的时候直接创建就可以了。\n但是在子线程使用Handler的话，就需要我们手动创建Looper了，\n示例:\nnew Thread() { @Override public void run() { Looper.prepare(); Handler handler = new Handler(); Looper.loop(); } }.start(); prepare()源码如下:\n/** Initialize the current thread as a looper. 77 * This gives you a chance to create handlers that then reference 78 * this looper, before actually starting the loop. Be sure to call 79 * {@link #loop()} after calling this method, and end it by calling 80 * {@link #quit()}. 81 */ 82 public static void prepare() { 83 prepare(true); 84 } 85 86 private static void prepare(boolean quitAllowed) { 87 if (sThreadLocal.get() != null) { 88 throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); 89 } 90 sThreadLocal.set(new Looper(quitAllowed)); 91 } 可以看到最终是调用了 此 Looper 所在线程的 **ThreadLocal.set()**方法，存了一个Looper对象进去。\n除了prepare()，还有一些其他方法，我们也需要知道\nloop() : 启动消息循环，，只有当Looper调用了loop()之后，整个消息循环才活了起来\nprepareMainLooper() : 给主线程创建Looper对象\ngetMainLooper() : 获得主线程的Looper对象\nquit() : 通知消息队列，直接退出消息循环，不等待当前正在处理的消息执行完，quit之后，再向消息队列中发送新的消息就会失败( Handler的send()方法就会返回false )\npublic void quit() { mQueue.quit(false); } quitSafety() : 通过消息队列，不再接收新的消息，等当前的消息队列中的消息处理完就退出。\npublic void quitSafely() { mQueue.quit(true); } 下面分析loop()的实现:\n/** 119 * Run the message queue in this thread. Be sure to call 120 * {@link #quit()} to end the loop. 121 */ 122 public static void loop() { 123 final Looper me = myLooper(); 124 if (me == null) { 125 throw new RuntimeException(\u0026#34;No Looper; Looper.prepare() wasn\u0026#39;t called on this thread.\u0026#34;); 126 } 127 final MessageQueue queue = me.mQueue; 128 129 ...//省略部分代码 133\t//从这里开启无限循环，直到 没有消息 134 for (;;) { 135 Message msg = queue.next(); // might block 136 if (msg == null) { 137 // No message indicates that the message queue is quitting. 138 return; 139 } 140 141 // This must be in a local variable, in case a UI event sets the logger 142 Printer logging = me.mLogging; 143 if (logging != null) { 144 logging.println(\u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; Dispatching to \u0026#34; + msg.target + \u0026#34; \u0026#34; + 145 msg.callback + \u0026#34;: \u0026#34; + msg.what); 146 } 147 148 msg.target.dispatchMessage(msg); 149\t...//省略部分代码 166 } 167 } 在 for 循环里 :\n通过queue.next()一直读取新的消息，如果没有消息 则退出循环。 接下来， msg.target.dispatchMessage(msg);，target是发送此消息的 Hander对像，通知Handler调用dispatchMessage()来接收消息。 (5),Handler的工作原理 Handler的主要工作就是 发送消息，接收消息。\n发送消息的方式有post(),send(),不过post()方法最后还是调用的send()方法\n发送消息的过程:\nsend类型的发送消息方法有很多，并且是嵌套的\nsendMessage()\npublic final boolean sendMessage(Message msg) { return sendMessageDelayed(msg, 0); } sendMessageDelayed()\npublic final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis \u0026lt; 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } sendMessageAtTime()\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \u0026#34; sendMessageAtTime() called with no mQueue\u0026#34;); Log.w(\u0026#34;Looper\u0026#34;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } 三种send的发送消息方式，最后都会通过enqueueMessage()来通知消息队列 插入这条新的消息。\nHandler.enqueueMessage\nprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);//调用消息队列的enqueueMessage() } 接收消息的过程\n接收消息由dispatchMessage(Message msg)为入口\ndispatchMessage()\npublic void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 这里的callback是我们调用 post(Runnable runnalbe) 时传入的Runnable对象，如果我们传入了Runnable对象\n就会执行Runnable的run方法:\nprivate static void handleCallback(Message message) { message.callback.run(); } 如果没有通过post传Runnable，就会看创建Handler时的构造方法中有没有传Runnable参数，传了的话由mCallback存储。\n这个mCallback是Handler内部的一个接口\npublic interface Callback { public boolean handleMessage(Message msg); } 如果构造Handler时也没有传Runnable对象，最终会执行handleMessage(msg),这个 方法就是我们创建handler时重写的handleMessage()方法.\n参考资料: Android艺术开发探索\nhttps://www.cnblogs.com/luxiaoxun/p/8744826.html\n(完~)\n","permalink":"https://chenyongda2018.github.io/posts/android/android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","summary":"\u003ch2 id=\"1android消息机制概述\"\u003e(1),Android消息机制概述\u003c/h2\u003e\n\u003cp\u003eAndroid中的消息机制主要指 \u003cstrong\u003eHandler的运行机制\u003c/strong\u003e 以及 \u003cstrong\u003eMessageQueue，Looper的工作过程\u003c/strong\u003e ，三者相互协作，保证着消息的接收，发送，处理，执行。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\" \" loading=\"lazy\" src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/28/16a645eb49972a0d~tplv-t2oaga2asx-image.image\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e​                                                            图片来自郭神的《第一行代码》\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e先简单的介绍一下 Android 中 消息机制大家庭的主要成员 :\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eHandler\u003c/strong\u003e : 是Android消息机制的上层接口，最为大家常用，相当于Android消息机制的入口，我们通过使用\u003ccode\u003eHandler\u003c/code\u003e发送消息来引起消息机制的循环。通常用于:在子线程执行完耗时任务完后，更新UI。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eMessageQueue\u003c/strong\u003e : 存储 \u003cstrong\u003e消息(Message)\u003c/strong\u003e 对象的消息队列，实则是单链表结构.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eLooper\u003c/strong\u003e : 用于无限的从 \u003ccode\u003eMessageQueue\u003c/code\u003e中取出消息，相当于消息的永动机，如果有新的消息，则处理执行，若没有，则就一直等待，堵塞。Looper** 所在的线程是 创建 \u003ccode\u003eHandler\u003c/code\u003e 时所在的线程。\u003c/p\u003e\n\u003cp\u003e主线程创建Handler时，会自动创建一个Looper,\u003cstrong\u003e但是子线程并不会自动创建Looper\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eThreadLocal\u003c/strong\u003e : 在每个线程互不干扰的存储，提供数据，以此来获取当前线程的\u003ccode\u003eLooper\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eActivityThread\u003c/strong\u003e : Android 的主线程，也叫UI线程，主线程被创建时 自动初始化主线程的 \u003ccode\u003eLooper\u003c/code\u003e对象。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"问题--大家都知道只有在ui线程才能对ui元素进行操作在子线程更改ui就会报错为什么\"\u003e问题 : 大家都知道只有在UI线程才能对UI元素进行操作，在子线程更改UI就会报错，为什么？\u003c/h4\u003e\n\u003cp\u003e看完\u003ca href=\"https://book.douban.com/subject/26599538/\"\u003e《Android艺术开发探索》\u003c/a\u003e 这本书的第10章之后我也才明白\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAndroid中的UI控件不是线程安全的，如果在子线程中也能修改UI元素，那多线程的时，共同访问同一个UI元素，就会导致这个UI元素处于我们不可预知的状态，这个线程让它往左一点，那个线程让它往右一点，UI该听谁的，好tm乱。。 干脆我就只听主线程的把。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"问题--那为什么不通过对访问ui控件的子线程加上锁机制呢-\"\u003e问题 : 那为什么不通过对访问UI控件的子线程加上锁机制呢 ？\u003c/h4\u003e\n\u003cp\u003e这个很简单了，如果为不同的线程访问同一UI元素加上锁机制，那我们程序员写相关代码的时候会变得超级麻烦。。。 改个UI还得考虑它是不是已经被别的线程占用了，被占用了，还得让那个线程释放锁。。。线程再多一点的话，大大地加大了程序员地工作量.\u003c/p\u003e\n\u003cp\u003e而且加上锁机制无疑会由于线程堵塞地原因降低访问UI的效率，帧率降低，体验也会不友好。\u003c/p\u003e\n\u003cp\u003e让UI元素只能再主线程访问就会省下很多事，创建一个\u003ccode\u003eHandler\u003c/code\u003e就行了。\u003c/p\u003e\n\u003cp\u003e下面从整体概述一下 消息机制的整个工作过程 :\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eHandler \u003c/code\u003e创建时会采用当前线程的 \u003ccode\u003eLooper\u003c/code\u003e来构建内部的消息循环系统，如果Handler在子线程，则一开始是没有\u003ccode\u003eLooper\u003c/code\u003e对象的(解决方法稍后介绍)，主线程\u003ccode\u003eActivityThread\u003c/code\u003e默认有一个Looper。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eHandler\u003c/code\u003e创建完毕，通过 \u003ccode\u003epost\u003c/code\u003e方法传入\u003ccode\u003eRunnable\u003c/code\u003e对象，或者通过\u003ccode\u003esendMessage(Message msg)\u003c/code\u003e发送消息。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epost()\u003c/code\u003e方法里也是通过调用\u003ccode\u003esend()\u003c/code\u003e实现的\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esend()\u003c/code\u003e方法被调用后，调用 MessageQueue的enqueueMessage()方法将消息发送到消息队列中，等待被处理。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eLooper\u003c/code\u003e对象运行在\u003ccode\u003eHandler\u003c/code\u003e所在的线程，从\u003ccode\u003eMessageQueue消息队列\u003c/code\u003e中不断地取出消息，处理，所以业务逻辑(通常是更新UI)就运行在Looper的线程中。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003c/h3\u003e\n\u003cp\u003e接下来从局部来分析消息机制的每个成员。\u003c/p\u003e","title":"Android消息机制全面解析"}]